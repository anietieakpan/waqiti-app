==> ./src/main/java/com/p2pfinance/notification/config/KafkaConsumerConfig.java <==
package com.p2pfinance.notification.config;

import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.annotation.EnableKafka;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.listener.ContainerProperties;
import org.springframework.kafka.listener.DefaultErrorHandler;
import org.springframework.util.backoff.FixedBackOff;

import java.util.HashMap;
import java.util.Map;

@Configuration
@EnableKafka
@Slf4j
public class KafkaConsumerConfig {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    @Value("${spring.kafka.consumer.group-id}")
    private String groupId;

    @Bean
    public ConsumerFactory<String, String> consumerFactory() {
        Map<String, Object> props = new HashMap<>();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);

        return new DefaultKafkaConsumerFactory<>(props);
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, String> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, String> factory =
                new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL_IMMEDIATE);

        // Configure error handler with retry
        DefaultErrorHandler errorHandler = new DefaultErrorHandler(
                (record, exception) -> {
                    log.error("Failed to process message: {}", record.value(), exception);
                },
                new FixedBackOff(1000L, 3) // Retry 3 times with 1s delay
        );

        factory.setCommonErrorHandler(errorHandler);

        return factory;
    }
}
==> ./src/main/java/com/p2pfinance/notification/config/FirebaseConfig.java <==
package com.p2pfinance.notification.config;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;
import com.google.firebase.messaging.FirebaseMessaging;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;

import java.io.IOException;
import java.io.InputStream;

@Configuration
@Slf4j
public class FirebaseConfig {

    @Value("${firebase.config-file}")
    private String firebaseConfigFile;

    @Bean
    public FirebaseMessaging firebaseMessaging() throws IOException {
        try {
            InputStream serviceAccount = new ClassPathResource(firebaseConfigFile).getInputStream();

            FirebaseOptions options = FirebaseOptions.builder()
                    .setCredentials(GoogleCredentials.fromStream(serviceAccount))
                    .build();

            if (FirebaseApp.getApps().isEmpty()) {
                FirebaseApp.initializeApp(options);
                log.info("Firebase application has been initialized");
            }

            return FirebaseMessaging.getInstance();
        } catch (Exception e) {
            log.error("Failed to initialize Firebase", e);
            // Create a mock implementation that always returns success
            return new MockFirebaseMessaging();
        }
    }

    // Mock implementation for development environments
    private static class MockFirebaseMessaging extends FirebaseMessaging {
        public MockFirebaseMessaging() {
            super(FirebaseApp.getInstance());
        }

        @Override
        public String send(com.google.firebase.messaging.Message message) {
            log.info("Mock FCM: Would send message to token: {}", message.getToken());
            return "mock-message-id-" + System.currentTimeMillis();
        }
    }
}
==> ./src/main/java/com/p2pfinance/notification/service/NotificationSenderService.java <==
package com.p2pfinance.notification.service;

import com.google.firebase.messaging.FirebaseMessaging;
import com.google.firebase.messaging.Message;
import com.google.firebase.messaging.Notification as FirebaseNotification;
import com.p2pfinance.notification.domain.Notification;
import com.p2pfinance.notification.domain.NotificationPreferences;
import com.p2pfinance.notification.repository.NotificationPreferencesRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;

import javax.mail.internet.MimeMessage;
import java.util.HashMap;
import java.util.Map;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationSenderService {
    private final NotificationPreferencesRepository preferencesRepository;
    private final JavaMailSender mailSender;
    private final FirebaseMessaging firebaseMessaging;

    /**
     * Sends an email notification
     */
    public boolean sendEmailNotification(Notification notification, String subject, String body) {
        log.info("Sending email notification: {}", notification.getId());

        // Get user's email from preferences
        NotificationPreferences preferences = preferencesRepository.findById(notification.getUserId())
                .orElse(null);

        if (preferences == null || preferences.getEmail() == null || preferences.getEmail().isEmpty()) {
            log.warn("No email address found for user: {}", notification.getUserId());
            return false;
        }

        try {
            // If subject or body is null, use title/message from notification
            if (subject == null) {
                subject = notification.getTitle();
            }

            if (body == null) {
                body = notification.getMessage();
            }

            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");

            helper.setTo(preferences.getEmail());
            helper.setSubject(subject);
            helper.setText(body, true); // true = HTML content

            mailSender.send(message);

            log.info("Email notification sent successfully: {}", notification.getId());
            return true;
        } catch (Exception e) {
            log.error("Error sending email notification: {}", notification.getId(), e);
            return false;
        }
    }

    /**
     * Sends an SMS notification
     */
    public boolean sendSmsNotification(Notification notification, String smsText) {
        log.info("Sending SMS notification: {}", notification.getId());

        // Get user's phone number from preferences
        NotificationPreferences preferences = preferencesRepository.findById(notification.getUserId())
                .orElse(null);

        if (preferences == null || preferences.getPhoneNumber() == null || preferences.getPhoneNumber().isEmpty()) {
            log.warn("No phone number found for user: {}", notification.getUserId());
            return false;
        }

        try {
            // If smsText is null, use message from notification
            if (smsText == null) {
                smsText = notification.getMessage();
            }

            // TODO: Implement actual SMS service integration
            // For example, using Twilio:
            // Twilio.init(ACCOUNT_SID, AUTH_TOKEN);
            // Message message = Message.creator(
            //     new PhoneNumber(preferences.getPhoneNumber()),
            //     new PhoneNumber(FROM_NUMBER),
            //     smsText)
            // .create();

            log.info("SMS notification sent successfully: {}", notification.getId());

            // Simulate success for now
            return true;
        } catch (Exception e) {
            log.error("Error sending SMS notification: {}", notification.getId(), e);
            return false;
        }
    }

    /**
     * Sends a push notification
     */
    public boolean sendPushNotification(Notification notification) {
        log.info("Sending push notification: {}", notification.getId());

        // Get user's device token from preferences
        NotificationPreferences preferences = preferencesRepository.findById(notification.getUserId())
                .orElse(null);

        if (preferences == null || preferences.getDeviceToken() == null || preferences.getDeviceToken().isEmpty()) {
            log.warn("No device token found for user: {}", notification.getUserId());
            return false;
        }

        try {
            // Create data payload
            Map<String, String> data = new HashMap<>();
            data.put("notificationId", notification.getId().toString());
            data.put("title", notification.getTitle());
            data.put("body", notification.getMessage());
            data.put("type", notification.getType().toString());
            data.put("category", notification.getCategory());

            if (notification.getReferenceId() != null) {
                data.put("referenceId", notification.getReferenceId());
            }

            if (notification.getActionUrl() != null) {
                data.put("actionUrl", notification.getActionUrl());
            }

            // Create Firebase message
            Message message = Message.builder()
                    .setToken(preferences.getDeviceToken())
                    .setNotification(FirebaseNotification.builder()
                            .setTitle(notification.getTitle())
                            .setBody(notification.getMessage())
                            .build())
                    .putAllData(data)
                    .build();

            // Send message
            firebaseMessaging.send(message);

            log.info("Push notification sent successfully: {}", notification.getId());
            return true;
        } catch (Exception e) {
            log.error("Error sending push notification: {}", notification.getId(), e);
            return false;
        }
    }
}
==> ./src/main/java/com/p2pfinance/notification/service/NotificationPreferencesService.java <==
package com.p2pfinance.notification.service;

import com.p2pfinance.notification.domain.NotificationPreferences;
import com.p2pfinance.notification.domain.NotificationType;
import com.p2pfinance.notification.dto.NotificationPreferencesResponse;
import com.p2pfinance.notification.dto.UpdatePreferencesRequest;
import com.p2pfinance.notification.repository.NotificationPreferencesRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Map;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationPreferencesService {
    private final NotificationPreferencesRepository preferencesRepository;

    /**
     * Gets or creates notification preferences for a user
     */
    @Transactional
    public NotificationPreferences getOrCreatePreferences(UUID userId) {
        log.info("Getting or creating notification preferences for user: {}", userId);

        return preferencesRepository.findById(userId)
                .orElseGet(() -> {
                    NotificationPreferences preferences = NotificationPreferences.createDefault(userId);
                    return preferencesRepository.save(preferences);
                });
    }

    /**
     * Updates notification preferences for a user
     */
    @Transactional
    public NotificationPreferencesResponse updatePreferences(UUID userId, UpdatePreferencesRequest request) {
        log.info("Updating notification preferences for user: {}", userId);

        NotificationPreferences preferences = getOrCreatePreferences(userId);

        // Update channel preferences
        if (request.getAppNotificationsEnabled() != null) {
            preferences.setAppNotificationsEnabled(request.getAppNotificationsEnabled());
        }

        if (request.getEmailNotificationsEnabled() != null) {
            preferences.setEmailNotificationsEnabled(request.getEmailNotificationsEnabled());
        }

        if (request.getSmsNotificationsEnabled() != null) {
            preferences.setSmsNotificationsEnabled(request.getSmsNotificationsEnabled());
        }

        if (request.getPushNotificationsEnabled() != null) {
            preferences.setPushNotificationsEnabled(request.getPushNotificationsEnabled());
        }

        // Update category preferences
        if (request.getCategoryPreferences() != null) {
            for (Map.Entry<String, Boolean> entry : request.getCategoryPreferences().entrySet()) {
                preferences.setCategoryPreference(entry.getKey(), entry.getValue());
            }
        }

        // Update quiet hours
        if (request.getQuietHoursStart() != null || request.getQuietHoursEnd() != null) {
            Integer start = request.getQuietHoursStart() != null ?
                    request.getQuietHoursStart() : preferences.getQuietHoursStart();
            Integer end = request.getQuietHoursEnd() != null ?
                    request.getQuietHoursEnd() : preferences.getQuietHoursEnd();

            preferences.setQuietHours(start, end);
        }

        // Update contact info
        if (request.getEmail() != null || request.getPhoneNumber() != null || request.getDeviceToken() != null) {
            preferences.updateContactInfo(
                    request.getEmail(),
                    request.getPhoneNumber(),
                    request.getDeviceToken()
            );
        }

        preferences = preferencesRepository.save(preferences);

        return mapToPreferencesResponse(preferences);
    }

    /**
     * Gets notification preferences for a user
     */
    @Transactional(readOnly = true)
    public NotificationPreferencesResponse getPreferences(UUID userId) {
        log.info("Getting notification preferences for user: {}", userId);

        NotificationPreferences preferences = getOrCreatePreferences(userId);

        return mapToPreferencesResponse(preferences);
    }

    /**
     * Checks if a notification type is enabled for a user and category
     */
    @Transactional(readOnly = true)
    public boolean isNotificationEnabled(UUID userId, String category, NotificationType type) {
        log.debug("Checking if notification is enabled for user: {}, category: {}, type: {}",
                userId, category, type);

        NotificationPreferences preferences = getOrCreatePreferences(userId);

        // Check if quiet hours
        if (preferences.isQuietHours()) {
            // During quiet hours, only allow app notifications
            return type == NotificationType.APP && preferences.isAppNotificationsEnabled() &&
                    preferences.shouldSendNotification(category, type);
        }

        return preferences.shouldSendNotification(category, type);
    }

    /**
     * Updates device token for push notifications
     */
    @Transactional
    public void updateDeviceToken(UUID userId, String deviceToken) {
        log.info("Updating device token for user: {}", userId);

        NotificationPreferences preferences = getOrCreatePreferences(userId);

        preferences.updateContactInfo(null, null, deviceToken);
        preferences.setPushNotificationsEnabled(true);

        preferencesRepository.save(preferences);
    }

    /**
     * Updates email address
     */
    @Transactional
    public void updateEmail(UUID userId, String email) {
        log.info("Updating email for user: {}", userId);

        NotificationPreferences preferences = getOrCreatePreferences(userId);

        preferences.updateContactInfo(email, null, null);

        preferencesRepository.save(preferences);
    }

    /**
     * Updates phone number
     */
    @Transactional
    public void updatePhoneNumber(UUID userId, String phoneNumber) {
        log.info("Updating phone number for user: {}", userId);

        NotificationPreferences preferences = getOrCreatePreferences(userId);

        preferences.updateContactInfo(null, phoneNumber, null);

        preferencesRepository.save(preferences);
    }

    /**
     * Maps a NotificationPreferences entity to a NotificationPreferencesResponse DTO
     */
    private NotificationPreferencesResponse mapToPreferencesResponse(NotificationPreferences preferences) {
        return NotificationPreferencesResponse.builder()
                .userId(preferences.getUserId())
                .appNotificationsEnabled(preferences.isAppNotificationsEnabled())
                .emailNotificationsEnabled(preferences.isEmailNotificationsEnabled())
                .smsNotificationsEnabled(preferences.isSmsNotificationsEnabled())
                .pushNotificationsEnabled(preferences.isPushNotificationsEnabled())
                .categoryPreferences(preferences.getCategoryPreferences())
                .quietHoursStart(preferences.getQuietHoursStart())
                .quietHoursEnd(preferences.getQuietHoursEnd())
                .email(preferences.getEmail())
                .phoneNumber(preferences.getPhoneNumber())
                .deviceTokenRegistered(preferences.getDeviceToken() != null)
                .updatedAt(preferences.getUpdatedAt())
                .build();
    }
}
==> ./src/main/java/com/p2pfinance/notification/service/NotificationTemplateService.java <==
package com.p2pfinance.notification.service;

import com.p2pfinance.notification.domain.NotificationTemplate;
import com.p2pfinance.notification.dto.NotificationTemplateRequest;
import com.p2pfinance.notification.dto.NotificationTemplateResponse;
import com.p2pfinance.notification.repository.NotificationTemplateRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationTemplateService {
    private final NotificationTemplateRepository templateRepository;
    private final TemplateRenderer templateRenderer;

    /**
     * Creates a new notification template
     */
    @Transactional
    @CacheEvict(value = "templates", allEntries = true)
    public NotificationTemplateResponse createTemplate(NotificationTemplateRequest request) {
        log.info("Creating notification template with code: {}", request.getCode());

        // Check if code already exists
        if (templateRepository.existsByCode(request.getCode())) {
            throw new IllegalArgumentException("Template with code already exists: " + request.getCode());
        }

        // Create the template
        NotificationTemplate template = NotificationTemplate.create(
                request.getCode(),
                request.getName(),
                request.getCategory(),
                request.getTitleTemplate(),
                request.getMessageTemplate()
        );

        // Set optional fields
        if (request.getEmailSubjectTemplate() != null) {
            template.setEmailTemplates(
                    request.getEmailSubjectTemplate(),
                    request.getEmailBodyTemplate()
            );
        }

        if (request.getSmsTemplate() != null) {
            template.setSmsTemplate(request.getSmsTemplate());
        }

        if (request.getActionUrlTemplate() != null) {
            template.setActionUrlTemplate(request.getActionUrlTemplate());
        }

        template.setEnabled(request.isEnabled());

        template = templateRepository.save(template);

        return mapToTemplateResponse(template);
    }

    /**
     * Updates an existing notification template
     */
    @Transactional
    @CacheEvict(value = "templates", allEntries = true)
    public NotificationTemplateResponse updateTemplate(UUID id, NotificationTemplateRequest request) {
        log.info("Updating notification template with ID: {}", id);

        NotificationTemplate template = templateRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Template not found with ID: " + id));

        // Update basic fields
        template.updateContent(request.getTitleTemplate(), request.getMessageTemplate());

        // Update optional fields
        if (request.getEmailSubjectTemplate() != null) {
            template.setEmailTemplates(
                    request.getEmailSubjectTemplate(),
                    request.getEmailBodyTemplate()
            );
        }

        if (request.getSmsTemplate() != null) {
            template.setSmsTemplate(request.getSmsTemplate());
        }

        if (request.getActionUrlTemplate() != null) {
            template.setActionUrlTemplate(request.getActionUrlTemplate());
        }

        template.setEnabled(request.isEnabled());

        template = templateRepository.save(template);

        return mapToTemplateResponse(template);
    }

    /**
     * Gets a template by ID
     */
    @Transactional(readOnly = true)
    public NotificationTemplateResponse getTemplateById(UUID id) {
        log.info("Getting notification template with ID: {}", id);

        NotificationTemplate template = templateRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Template not found with ID: " + id));

        return mapToTemplateResponse(template);
    }

    /**
     * Gets a template by code
     */
    @Transactional(readOnly = true)
    @Cacheable(value = "templates", key = "#code")
    public NotificationTemplate getTemplateByCode(String code) {
        log.info("Getting notification template with code: {}", code);

        return templateRepository.findByCode(code)
                .orElseThrow(() -> new IllegalArgumentException("Template not found with code: " + code));
    }

    /**
     * Gets all templates
     */
    @Transactional(readOnly = true)
    public List<NotificationTemplateResponse> getAllTemplates() {
        log.info("Getting all notification templates");

        List<NotificationTemplate> templates = templateRepository.findAll();

        return templates.stream()
                .map(this::mapToTemplateResponse)
                .collect(Collectors.toList());
    }

    /**
     * Gets templates by category
     */
    @Transactional(readOnly = true)
    public List<NotificationTemplateResponse> getTemplatesByCategory(String category) {
        log.info("Getting notification templates for category: {}", category);

        List<NotificationTemplate> templates = templateRepository.findByCategory(category);

        return templates.stream()
                .map(this::mapToTemplateResponse)
                .collect(Collectors.toList());
    }

    /**
     * Enables or disables a template
     */
    @Transactional
    @CacheEvict(value = "templates", allEntries = true)
    public NotificationTemplateResponse setTemplateEnabled(UUID id, boolean enabled) {
        log.info("Setting template {} to enabled={}", id, enabled);

        NotificationTemplate template = templateRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Template not found with ID: " + id));

        template.setEnabled(enabled);
        template = templateRepository.save(template);

        return mapToTemplateResponse(template);
    }

    /**
     * Renders a template with the given parameters
     */
    public String renderTemplate(String template, Object model) {
        return templateRenderer.renderTemplate(template, model);
    }

    /**
     * Maps a NotificationTemplate entity to a NotificationTemplateResponse DTO
     */
    private NotificationTemplateResponse mapToTemplateResponse(NotificationTemplate template) {
        return NotificationTemplateResponse.builder()
                .id(template.getId())
                .code(template.getCode())
                .name(template.getName())
                .category(template.getCategory())
                .titleTemplate(template.getTitleTemplate())
                .messageTemplate(template.getMessageTemplate())
                .emailSubjectTemplate(template.getEmailSubjectTemplate())
                .emailBodyTemplate(template.getEmailBodyTemplate())
                .smsTemplate(template.getSmsTemplate())
                .actionUrlTemplate(template.getActionUrlTemplate())
                .enabled(template.isEnabled())
                .createdAt(template.getCreatedAt())
                .updatedAt(template.getUpdatedAt())
                .build();
    }
}
==> ./src/main/java/com/p2pfinance/notification/service/NotificationService.java <==
package com.p2pfinance.notification.service;

import com.p2pfinance.notification.domain.*;
import com.p2pfinance.notification.dto.NotificationListResponse;
import com.p2pfinance.notification.dto.NotificationResponse;
import com.p2pfinance.notification.dto.SendNotificationRequest;
import com.p2pfinance.notification.repository.NotificationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationService {
    private final NotificationRepository notificationRepository;
    private final NotificationTemplateService templateService;
    private final NotificationPreferencesService preferencesService;
    private final NotificationSenderService senderService;

    /**
     * Sends a notification using a template
     */
    @Transactional
    public List<NotificationResponse> sendNotification(SendNotificationRequest request) {
        log.info("Sending notification to user: {}, template: {}",
                request.getUserId(), request.getTemplateCode());

        // Get the template
        NotificationTemplate template = templateService.getTemplateByCode(request.getTemplateCode());

        if (!template.isEnabled()) {
            log.warn("Template is disabled: {}", request.getTemplateCode());
            return List.of();
        }

        // Render the templates
        String title = templateService.renderTemplate(template.getTitleTemplate(), request.getParameters());
        String message = templateService.renderTemplate(template.getMessageTemplate(), request.getParameters());

        // Determine which notification types to send based on request and user preferences
        List<NotificationType> typesToSend = determineNotificationTypes(
                request.getUserId(), template.getCategory(), request.getTypes());

        if (typesToSend.isEmpty()) {
            log.info("No notification types enabled for user: {}, template: {}",
                    request.getUserId(), request.getTemplateCode());
            return List.of();
        }

        // Create and send notifications for each type
        List<Notification> notifications = typesToSend.stream()
                .map(type -> createAndSendNotification(
                        request.getUserId(),
                        title,
                        message,
                        type,
                        template.getCategory(),
                        request.getReferenceId(),
                        request.getActionUrl(),
                        request.getExpiresAt(),
                        template,
                        request.getParameters()
                ))
                .collect(Collectors.toList());

        return notifications.stream()
                .map(this::mapToNotificationResponse)
                .collect(Collectors.toList());
    }

    /**
     * Determines which notification types to send based on user preferences
     */
    private List<NotificationType> determineNotificationTypes(UUID userId,
                                                              String category,
                                                              String[] requestedTypes) {
        // If specific types are requested, use those (still check preferences)
        if (requestedTypes != null && requestedTypes.length > 0) {
            return Arrays.stream(requestedTypes)
                    .map(type -> NotificationType.valueOf(type))
                    .filter(type -> preferencesService.isNotificationEnabled(userId, category, type))
                    .collect(Collectors.toList());
        }

        // Otherwise, determine based on user preferences
        List<NotificationType> enabledTypes = List.of();

        for (NotificationType type : NotificationType.values()) {
            if (preferencesService.isNotificationEnabled(userId, category, type)) {
                enabledTypes.add(type);
            }
        }

        return enabledTypes;
    }

    /**
     * Creates and sends a notification
     */
    private Notification createAndSendNotification(UUID userId, String title, String message,
                                                   NotificationType type, String category,
                                                   String referenceId, String actionUrl,
                                                   LocalDateTime expiresAt, NotificationTemplate template,
                                                   Map<String, Object> parameters) {
        // Create the notification
        Notification notification = Notification.create(
                userId, title, message, type, category);

        if (referenceId != null) {
            notification.setReferenceId(referenceId);
        }

        if (actionUrl != null) {
            notification.setActionUrl(actionUrl);
        } else if (template.getActionUrlTemplate() != null) {
            String renderedActionUrl = templateService.renderTemplate(
                    template.getActionUrlTemplate(), parameters);
            notification.setActionUrl(renderedActionUrl);
        }

        if (expiresAt != null) {
            notification.setExpiryDate(expiresAt);
        }

        // Save the notification
        notification = notificationRepository.save(notification);

        // Send the notification
        try {
            boolean sent = false;

            switch (type) {
                case APP -> sent = true; // App notifications are always "sent" as they're stored in DB
                case EMAIL -> sent = senderService.sendEmailNotification(
                        notification,
                        templateService.renderTemplate(template.getEmailSubjectTemplate(), parameters),
                        templateService.renderTemplate(template.getEmailBodyTemplate(), parameters));
                case SMS -> sent = senderService.sendSmsNotification(
                        notification,
                        templateService.renderTemplate(template.getSmsTemplate(), parameters));
                case PUSH -> sent = senderService.sendPushNotification(notification);
            }

            // Update delivery status
            if (sent) {
                notification.updateDeliveryStatus(DeliveryStatus.SENT, null);
            } else {
                notification.updateDeliveryStatus(
                        DeliveryStatus.FAILED, "Failed to send notification");
            }
        } catch (Exception e) {
            log.error("Error sending notification", e);
            notification.updateDeliveryStatus(
                    DeliveryStatus.FAILED, e.getMessage());
        }

        return notificationRepository.save(notification);
    }

    /**
     * Gets notifications for a user
     */
    @Transactional(readOnly = true)
    public NotificationListResponse getNotifications(UUID userId, Pageable pageable) {
        log.info("Getting notifications for user: {}", userId);

        Page<Notification> notificationsPage =
                notificationRepository.findByUserIdOrderByCreatedAtDesc(userId, pageable);

        long unreadCount = notificationRepository.countByUserIdAndReadFalse(userId);

        List<NotificationResponse> notifications = notificationsPage.getContent().stream()
                .map(this::mapToNotificationResponse)
                .collect(Collectors.toList());

        return NotificationListResponse.builder()
                .notifications(notifications)
                .unreadCount(unreadCount)
                .totalPages(notificationsPage.getTotalPages())
                .totalElements(notificationsPage.getTotalElements())
                .page(pageable.getPageNumber())
                .size(pageable.getPageSize())
                .build();
    }

    /**
     * Gets unread notifications for a user
     */
    @Transactional(readOnly = true)
    public NotificationListResponse getUnreadNotifications(UUID userId, Pageable pageable) {
        log.info("Getting unread notifications for user: {}", userId);

        Page<Notification> notificationsPage =
                notificationRepository.findByUserIdAndReadFalseOrderByCreatedAtDesc(userId, pageable);

        long unreadCount = notificationsPage.getTotalElements();

        List<NotificationResponse> notifications = notificationsPage.getContent().stream()
                .map(this::mapToNotificationResponse)
                .collect(Collectors.toList());

        return NotificationListResponse.builder()
                .notifications(notifications)
                .unreadCount(unreadCount)
                .totalPages(notificationsPage.getTotalPages())
                .totalElements(notificationsPage.getTotalElements())
                .page(pageable.getPageNumber())
                .size(pageable.getPageSize())
                .build();
    }

    /**
     * Gets a notification by ID
     */
    @Transactional(readOnly = true)
    public NotificationResponse getNotification(UUID id) {
        log.info("Getting notification with ID: {}", id);

        Notification notification = notificationRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Notification not found with ID: " + id));

        return mapToNotificationResponse(notification);
    }

    /**
     * Marks a notification as read
     */
    @Transactional
    public NotificationResponse markAsRead(UUID id) {
        log.info("Marking notification as read: {}", id);

        Notification notification = notificationRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Notification not found with ID: " + id));

        notification.markAsRead();
        notification = notificationRepository.save(notification);

        return mapToNotificationResponse(notification);
    }

    /**
     * Marks all notifications as read for a user
     */
    @Transactional
    public void markAllAsRead(UUID userId) {
        log.info("Marking all notifications as read for user: {}", userId);

        Page<Notification> unreadNotifications =
                notificationRepository.findByUserIdAndReadFalseOrderByCreatedAtDesc(
                        userId, Pageable.unpaged());

        for (Notification notification : unreadNotifications) {
            notification.markAsRead();
            notificationRepository.save(notification);
        }
    }

    /**
     * Scheduled task to retry failed notifications
     */
    @Scheduled(fixedDelay = 60000) // Every minute
    @Transactional
    public void retryFailedNotifications() {
        log.info("Retrying failed notifications");

        List<Notification> failedNotifications =
                notificationRepository.findByDeliveryStatus(DeliveryStatus.FAILED);

        for (Notification notification : failedNotifications) {
            try {
                boolean sent = false;

                switch (notification.getType()) {
                    case APP -> sent = true;
                    case EMAIL -> sent = senderService.sendEmailNotification(notification, null, null);
                    case SMS -> sent = senderService.sendSmsNotification(notification, null);
                    case PUSH -> sent = senderService.sendPushNotification(notification);
                }

                if (sent) {
                    notification.updateDeliveryStatus(DeliveryStatus.SENT, null);
                    notificationRepository.save(notification);
                }
            } catch (Exception e) {
                log.error("Error retrying notification: {}", notification.getId(), e);
            }
        }
    }

    /**
     * Scheduled task to clean up expired notifications
     */
    @Scheduled(cron = "0 0 0 * * *") // Every day at midnight
    @Transactional
    public void cleanupExpiredNotifications() {
        log.info("Cleaning up expired notifications");

        List<Notification> expiredNotifications =
                notificationRepository.findByReadFalseAndExpiresAtBeforeAndDeliveryStatus(
                        LocalDateTime.now(), DeliveryStatus.SENT);

        for (Notification notification : expiredNotifications) {
            notification.updateDeliveryStatus(DeliveryStatus.EXPIRED, "Notification expired");
            notificationRepository.save(notification);
        }
    }

    /**
     * Maps a Notification entity to a NotificationResponse DTO
     */
    private NotificationResponse mapToNotificationResponse(Notification notification) {
        return NotificationResponse.builder()
                .id(notification.getId())
                .userId(notification.getUserId())
                .title(notification.getTitle())
                .message(notification.getMessage())
                .type(notification.getType().toString())
                .category(notification.getCategory())
                .referenceId(notification.getReferenceId())
                .read(notification.isRead())
                .actionUrl(notification.getActionUrl())
                .createdAt(notification.getCreatedAt())
                .expiresAt(notification.getExpiresAt())
                .readAt(notification.getReadAt())
                .deliveryStatus(notification.getDeliveryStatus().toString())
                .build();
    }
}
==> ./src/main/java/com/p2pfinance/notification/service/TemplateRenderer.java <==
package com.p2pfinance.notification.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.thymeleaf.ITemplateEngine;
import org.thymeleaf.context.Context;

import java.util.Locale;
import java.util.Map;

@Service
@RequiredArgsConstructor
@Slf4j
public class TemplateRenderer {
    private final ITemplateEngine templateEngine;

    /**
     * Renders a template string with the given model
     */
    public String renderTemplate(String template, Object model) {
        try {
            Context context = new Context(Locale.getDefault());

            if (model instanceof Map) {
                @SuppressWarnings("unchecked")
                Map<String, Object> modelMap = (Map<String, Object>) model;
                modelMap.forEach(context::setVariable);
            } else {
                context.setVariable("model", model);
            }

            // Wrap the template in Thymeleaf processing tags
            String wrappedTemplate = "<div th:remove=\"tag\">" + template + "</div>";

            return templateEngine.process(wrappedTemplate, context);
        } catch (Exception e) {
            log.error("Error rendering template: {}", template, e);
            // Return the original template in case of an error
            return template;
        }
    }
}
==> ./src/main/java/com/p2pfinance/notification/event/ScheduledPaymentEvent.java <==
package com.p2pfinance.notification.event;

import com.p2pfinance.notification.event.NotificationEvent;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Event for scheduled payments
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ScheduledPaymentEvent extends NotificationEvent {
    private UUID userId;
    private UUID paymentId;
    private String status; // CREATED, EXECUTED, FAILED, COMPLETED, CANCELED
    private UUID senderId;
    private String senderName;
    private UUID recipientId;
    private String recipientName;
    private BigDecimal amount;
    private String currency;
    private LocalDateTime executionDate;

    public ScheduledPaymentEvent(UUID userId, UUID paymentId, String status,
                                 BigDecimal amount, String currency) {
        super();
        this.eventType = "SCHEDULED_PAYMENT";
        this.userId = userId;
        this.paymentId = paymentId;
        this.status = status;
        this.amount = amount;
        this.currency = currency;
    }
}
==> ./src/main/java/com/p2pfinance/notification/event/NotificationEvent.java <==
package com.p2pfinance.notification.event;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.UUID; /**
 * Base class for all notification events
 */
@Data
public abstract class NotificationEvent {
    private String eventId;
    private String eventType;
    private LocalDateTime timestamp;
    private UUID userId;

    public NotificationEvent() {
        this.eventId = UUID.randomUUID().toString();
        this.timestamp = LocalDateTime.now();
    }
}

==> ./src/main/java/com/p2pfinance/notification/event/WalletTransactionEvent.java <==
import com.p2pfinance.notification.event.NotificationEvent;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.UUID;

/**
 * Event for wallet transactions
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class WalletTransactionEvent extends NotificationEvent {
    private UUID userId;
    private UUID walletId;
    private String transactionType; // DEPOSIT, WITHDRAWAL, TRANSFER
    private BigDecimal amount;
    private String currency;
    private UUID sourceWalletId;
    private UUID targetWalletId;
    private UUID counterpartyUserId;
    private String counterpartyName;
    private BigDecimal newBalance;
    private UUID transactionId;

    public WalletTransactionEvent(UUID userId, UUID walletId, String transactionType,
                                  BigDecimal amount, String currency) {
        super();
        this.eventType = "WALLET_TRANSACTION";
        this.userId = userId;
        this.walletId = walletId;
        this.transactionType = transactionType;
        this.amount = amount;
        this.currency = currency;
    }
}
==> ./src/main/java/com/p2pfinance/notification/event/UserVerifiedEvent.java <==
package com.p2pfinance.notification.event;

import com.p2pfinance.notification.event.NotificationEvent;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.UUID;


import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID;

/**
 * Event for user verification
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserVerifiedEvent extends NotificationEvent {
    private UUID userId;
    private String username;

    public UserVerifiedEvent(UUID userId, String username) {
        super();
        this.eventType = "USER_VERIFIED";
        this.userId = userId;
        this.username = username;
    }
}
==> ./src/main/java/com/p2pfinance/notification/event/SecurityEvent.java <==
package com.p2pfinance.notification.event;

import com.p2pfinance.notification.event.NotificationEvent;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Event for security related notifications
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SecurityEvent extends NotificationEvent {
    private UUID userId;
    private String securityEventType; // LOGIN, PASSWORD_CHANGED, DEVICE_ADDED, etc.
    private String ipAddress;
    private String deviceInfo;
    private String location;
    private LocalDateTime eventTime;
    private boolean suspicious;

    public SecurityEvent(UUID userId, String securityEventType) {
        super();
        this.eventType = "SECURITY";
        this.userId = userId;
        this.securityEventType = securityEventType;
        this.eventTime = LocalDateTime.now();
    }
}
==> ./src/main/java/com/p2pfinance/notification/event/SplitPaymentEvent.java <==
package com.p2pfinance.notification.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID;


/**
 * Event for split payments
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SplitPaymentEvent extends NotificationEvent {
    private UUID userId;
    private UUID paymentId;
    private String status; // CREATED, PARTICIPANT_ADDED, PARTICIPANT_PAID, COMPLETED, CANCELED
    private UUID organizerId;
    private String organizerName;
    private String title;
    private BigDecimal totalAmount;
    private BigDecimal userAmount;
    private String currency;
    private UUID participantId;
    private String participantName;

    public SplitPaymentEvent(UUID userId, UUID paymentId, String status,
                             String title, BigDecimal totalAmount, String currency) {
        super();
        this.eventType = "SPLIT_PAYMENT";
        this.userId = userId;
        this.paymentId = paymentId;
        this.status = status;
        this.title = title;
        this.totalAmount = totalAmount;
        this.currency = currency;
    }
}


==> ./src/main/java/com/p2pfinance/notification/event/UserRegisteredEvent.java <==
package com.p2pfinance.notification.event;

import com.p2pfinance.notification.event.NotificationEvent;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.UUID;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Map;

/**
 * Event for user registration
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserRegisteredEvent extends NotificationEvent {
    private UUID userId;
    private String username;
    private String email;

    public UserRegisteredEvent(UUID userId, String username, String email) {
        super();
        this.eventType = "USER_REGISTERED";
        this.userId = userId;
        this.username = username;
        this.email = email;
    }
}
==> ./src/main/java/com/p2pfinance/notification/event/PaymentRequestEvent.java <==
package com.p2pfinance.notification.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID;


/**
 * Event for payment requests
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PaymentRequestEvent extends NotificationEvent {
    private UUID userId;
    private UUID requestId;
    private String status; // CREATED, APPROVED, REJECTED, CANCELED, EXPIRED
    private UUID requestorId;
    private String requestorName;
    private UUID recipientId;
    private String recipientName;
    private BigDecimal amount;
    private String currency;

    public PaymentRequestEvent(UUID userId, UUID requestId, String status,
                               BigDecimal amount, String currency) {
        super();
        this.eventType = "PAYMENT_REQUEST";
        this.userId = userId;
        this.requestId = requestId;
        this.status = status;
        this.amount = amount;
        this.currency = currency;
    }
}
==> ./src/main/java/com/p2pfinance/notification/repository/NotificationRepository.java <==
package com.p2pfinance.notification.repository;

import com.p2pfinance.notification.domain.DeliveryStatus;
import com.p2pfinance.notification.domain.Notification;
import com.p2pfinance.notification.domain.NotificationType;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Repository
public interface NotificationRepository extends JpaRepository<Notification, UUID> {
    /**
     * Find notifications by user ID, sorted by creation date
     */
    Page<Notification> findByUserIdOrderByCreatedAtDesc(UUID userId, Pageable pageable);

    /**
     * Find unread notifications by user ID
     */
    Page<Notification> findByUserIdAndReadFalseOrderByCreatedAtDesc(UUID userId, Pageable pageable);

    /**
     * Find notifications by user ID and category
     */
    Page<Notification> findByUserIdAndCategoryOrderByCreatedAtDesc(UUID userId, String category, Pageable pageable);

    /**
     * Find notifications by delivery status
     */
    List<Notification> findByDeliveryStatus(DeliveryStatus status);

    /**
     * Find notifications by type and delivery status
     */
    List<Notification> findByTypeAndDeliveryStatus(NotificationType type, DeliveryStatus status);

    /**
     * Count unread notifications by user ID
     */
    long countByUserIdAndReadFalse(UUID userId);

    /**
     * Find expired unread notifications to clean up
     */
    List<Notification> findByReadFalseAndExpiresAtBeforeAndDeliveryStatus(
            LocalDateTime now, DeliveryStatus status);

    /**
     * Find notifications by reference ID
     */
    List<Notification> findByReferenceId(String referenceId);

    /**
     * Find latest notification by user ID and category
     */
    @Query("SELECT n FROM Notification n WHERE n.userId = :userId AND n.category = :category " +
            "ORDER BY n.createdAt DESC LIMIT 1")
    Notification findLatestByUserIdAndCategory(@Param("userId") UUID userId, @Param("category") String category);
}
==> ./src/main/java/com/p2pfinance/notification/repository/NotificationPreferencesRepository.java <==
package com.p2pfinance.notification.repository;

import com.p2pfinance.notification.domain.NotificationPreferences;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.UUID;

@Repository
public interface NotificationPreferencesRepository extends JpaRepository<NotificationPreferences, UUID> {
    /**
     * Find users who have enabled a specific notification type
     */
    @Query("SELECT np.userId FROM NotificationPreferences np WHERE " +
           "(:type = 'APP' AND np.appNotificationsEnabled = true) OR " +
           "(:type = 'EMAIL' AND np.emailNotificationsEnabled = true) OR " +
           "(:type = 'SMS' AND np.smsNotificationsEnabled = true) OR " +
           "(:type = 'PUSH' AND np.pushNotificationsEnabled = true)")
    List<UUID> findUserIdsWithEnabledNotificationType(@Param("type") String type);

    /**
     * Find users who have enabled a specific category
     */
    @Query("SELECT np.userId FROM NotificationPreferences np JOIN np.categoryPreferences cp " +
           "WHERE KEY(cp) = :category AND VALUE(cp) = true")
    List<UUID> findUserIdsWithEnabledCategory(@Param("category") String category);

    /**
     * Find users with device tokens for push notifications
     */
    @Query("SELECT np FROM NotificationPreferences np WHERE " +
           "np.pushNotificationsEnabled = true AND np.deviceToken IS NOT NULL")
    List<NotificationPreferences> findUsersForPushNotifications();
}
==> ./src/main/java/com/p2pfinance/notification/repository/NotificationTemplateRepository.java <==
package com.p2pfinance.notification.repository;

import com.p2pfinance.notification.domain.NotificationTemplate;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface NotificationTemplateRepository extends JpaRepository<NotificationTemplate, UUID> {
    /**
     * Find template by code
     */
    Optional<NotificationTemplate> findByCode(String code);

    /**
     * Find templates by category
     */
    List<NotificationTemplate> findByCategory(String category);

    /**
     * Find enabled templates
     */
    List<NotificationTemplate> findByEnabledTrue();

    /**
     * Find enabled templates by category
     */
    List<NotificationTemplate> findByCategoryAndEnabledTrue(String category);

    /**
     * Check if a template exists by code
     */
    boolean existsByCode(String code);
}
==> ./src/main/java/com/p2pfinance/notification/domain/NotificationTemplate.java <==
package com.p2pfinance.notification.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "notification_templates")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class NotificationTemplate {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false, unique = true)
    private String code;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, length = 100)
    private String category;

    @Column(nullable = false, length = 200)
    private String titleTemplate;

    @Column(nullable = false, length = 2000)
    private String messageTemplate;

    @Column(length = 2000)
    private String emailSubjectTemplate;

    @Column(length = 5000)
    private String emailBodyTemplate;

    @Column(length = 200)
    private String smsTemplate;

    @Column(name = "action_url_template")
    private String actionUrlTemplate;

    @Column(nullable = false)
    private boolean enabled;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    // Audit fields
    @Setter
    @Column(name = "created_by")
    private String createdBy;

    @Setter
    @Column(name = "updated_by")
    private String updatedBy;

    /**
     * Creates a new notification template
     */
    public static NotificationTemplate create(String code, String name, String category,
                                              String titleTemplate, String messageTemplate) {
        NotificationTemplate template = new NotificationTemplate();
        template.code = code;
        template.name = name;
        template.category = category;
        template.titleTemplate = titleTemplate;
        template.messageTemplate = messageTemplate;
        template.enabled = true;
        template.createdAt = LocalDateTime.now();
        template.updatedAt = LocalDateTime.now();
        return template;
    }

    /**
     * Sets the email templates
     */
    public void setEmailTemplates(String emailSubjectTemplate, String emailBodyTemplate) {
        this.emailSubjectTemplate = emailSubjectTemplate;
        this.emailBodyTemplate = emailBodyTemplate;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Sets the SMS template
     */
    public void setSmsTemplate(String smsTemplate) {
        this.smsTemplate = smsTemplate;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Sets the action URL template
     */
    public void setActionUrlTemplate(String actionUrlTemplate) {
        this.actionUrlTemplate = actionUrlTemplate;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Enables or disables the template
     */
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates the template content
     */
    public void updateContent(String titleTemplate, String messageTemplate) {
        this.titleTemplate = titleTemplate;
        this.messageTemplate = messageTemplate;
        this.updatedAt = LocalDateTime.now();
    }
}
==> ./src/main/java/com/p2pfinance/notification/domain/NotificationCategory.java <==
package com.p2pfinance.notification.domain;

/**
 * Represents the categories of notifications
 */
public enum NotificationCategory {
    ACCOUNT,            // Account-related notifications (registration, verification, etc.)
    TRANSACTION,        // Transaction-related notifications (deposits, withdrawals, transfers)
    PAYMENT_REQUEST,    // Payment request notifications
    SCHEDULED_PAYMENT,  // Scheduled payment notifications
    SPLIT_PAYMENT,      // Split payment notifications
    SECURITY            // Security-related notifications (login, password change, etc.)
}

==> ./src/main/java/com/p2pfinance/notification/domain/NotificationPreferences.java <==
package com.p2pfinance.notification.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Entity
@Table(name = "notification_preferences")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class NotificationPreferences {
    @Id
    private UUID userId;

    @Column(nullable = false)
    private boolean appNotificationsEnabled;

    @Column(nullable = false)
    private boolean emailNotificationsEnabled;

    @Column(nullable = false)
    private boolean smsNotificationsEnabled;

    @Column(nullable = false)
    private boolean pushNotificationsEnabled;

    @ElementCollection
    @CollectionTable(name = "category_preferences",
            joinColumns = @JoinColumn(name = "user_id"))
    @MapKeyColumn(name = "category")
    @Column(name = "enabled")
    private Map<String, Boolean> categoryPreferences = new HashMap<>();

    @Column(name = "quiet_hours_start")
    private Integer quietHoursStart;

    @Column(name = "quiet_hours_end")
    private Integer quietHoursEnd;

    @Column(name = "email")
    private String email;

    @Column(name = "phone_number")
    private String phoneNumber;

    @Column(name = "device_token")
    private String deviceToken;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @Version
    private Long version;

    // Audit fields
    @Setter
    @Column(name = "created_by")
    private String createdBy;

    @Setter
    @Column(name = "updated_by")
    private String updatedBy;

    /**
     * Creates default notification preferences for a user
     */
    public static NotificationPreferences createDefault(UUID userId) {
        NotificationPreferences preferences = new NotificationPreferences();
        preferences.userId = userId;
        preferences.appNotificationsEnabled = true;
        preferences.emailNotificationsEnabled = true;
        preferences.smsNotificationsEnabled = false;
        preferences.pushNotificationsEnabled = false;

        // Enable all categories by default
        for (NotificationCategory category : NotificationCategory.values()) {
            preferences.categoryPreferences.put(category.name(), true);
        }

        preferences.createdAt = LocalDateTime.now();
        preferences.updatedAt = LocalDateTime.now();

        return preferences;
    }

    /**
     * Updates the app notification setting
     */
    public void setAppNotificationsEnabled(boolean enabled) {
        this.appNotificationsEnabled = enabled;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates the email notification setting
     */
    public void setEmailNotificationsEnabled(boolean enabled) {
        this.emailNotificationsEnabled = enabled;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates the SMS notification setting
     */
    public void setSmsNotificationsEnabled(boolean enabled) {
        this.smsNotificationsEnabled = enabled;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates the push notification setting
     */
    public void setPushNotificationsEnabled(boolean enabled) {
        this.pushNotificationsEnabled = enabled;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates a category preference
     */
    public void setCategoryPreference(String category, boolean enabled) {
        this.categoryPreferences.put(category, enabled);
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates quiet hours
     */
    public void setQuietHours(Integer start, Integer end) {
        this.quietHoursStart = start;
        this.quietHoursEnd = end;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates contact information
     */
    public void updateContactInfo(String email, String phoneNumber, String deviceToken) {
        if (email != null) {
            this.email = email;
        }

        if (phoneNumber != null) {
            this.phoneNumber = phoneNumber;
        }

        if (deviceToken != null) {
            this.deviceToken = deviceToken;
        }

        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Checks if notifications should be sent based on category and type
     */
    public boolean shouldSendNotification(String category, NotificationType type) {
        // Check category preference
        Boolean categoryEnabled = categoryPreferences.get(category);
        if (categoryEnabled == null || !categoryEnabled) {
            return false;
        }

        // Check type preference
        switch (type) {
            case APP -> {
                return appNotificationsEnabled;
            }
            case EMAIL -> {
                return emailNotificationsEnabled && email != null && !email.isEmpty();
            }
            case SMS -> {
                return smsNotificationsEnabled && phoneNumber != null && !phoneNumber.isEmpty();
            }
            case PUSH -> {
                return pushNotificationsEnabled && deviceToken != null && !deviceToken.isEmpty();
            }
            default -> {
                return false;
            }
        }
    }

    /**
     * Checks if current time is within quiet hours
     */
    public boolean isQuietHours() {
        if (quietHoursStart == null || quietHoursEnd == null) {
            return false;
        }

        int currentHour = LocalDateTime.now().getHour();

        if (quietHoursStart <= quietHoursEnd) {
            // E.g., 22:00 - 06:00
            return currentHour >= quietHoursStart && currentHour < quietHoursEnd;
        } else {
            // E.g., 22:00 - 06:00 (spans midnight)
            return currentHour >= quietHoursStart || currentHour < quietHoursEnd;
        }
    }
}
==> ./src/main/java/com/p2pfinance/notification/domain/NotificationType.java <==
package com.p2pfinance.notification.domain;

/**
 * Represents the types of notifications
 */
public enum NotificationType {
    APP,        // In-app notification
    EMAIL,      // Email notification
    SMS,        // SMS notification
    PUSH        // Push notification to mobile device
}

==> ./src/main/java/com/p2pfinance/notification/domain/Notification.java <==
package com.p2pfinance.notification.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "notifications")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false)
    private UUID userId;

    @Column(nullable = false, length = 100)
    private String title;

    @Column(nullable = false, length = 1000)
    private String message;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private NotificationType type;

    @Column(length = 100)
    private String category;

    @Column(name = "reference_id")
    private String referenceId;

    @Column(nullable = false)
    private boolean read;

    @Column(name = "action_url")
    private String actionUrl;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    @Column(name = "expires_at")
    private LocalDateTime expiresAt;

    @Column(name = "read_at")
    private LocalDateTime readAt;

    @Enumerated(EnumType.STRING)
    @Column(name = "delivery_status", nullable = false)
    private DeliveryStatus deliveryStatus;

    @Column(name = "delivery_error")
    private String deliveryError;

    @Version
    private Long version;

    // Audit fields
    @Setter
    @Column(name = "created_by")
    private String createdBy;

    /**
     * Creates a new notification
     */
    public static Notification create(UUID userId, String title, String message,
                                      NotificationType type, String category) {
        Notification notification = new Notification();
        notification.userId = userId;
        notification.title = title;
        notification.message = message;
        notification.type = type;
        notification.category = category;
        notification.read = false;
        notification.createdAt = LocalDateTime.now();
        notification.deliveryStatus = DeliveryStatus.PENDING;
        return notification;
    }

    /**
     * Marks the notification as read
     */
    public void markAsRead() {
        if (!this.read) {
            this.read = true;
            this.readAt = LocalDateTime.now();
        }
    }

    /**
     * Updates the delivery status
     */
    public void updateDeliveryStatus(DeliveryStatus status, String error) {
        this.deliveryStatus = status;
        this.deliveryError = error;
    }

    /**
     * Sets the reference ID
     */
    public void setReferenceId(String referenceId) {
        this.referenceId = referenceId;
    }

    /**
     * Sets the action URL
     */
    public void setActionUrl(String actionUrl) {
        this.actionUrl = actionUrl;
    }

    /**
     * Sets the expiry date
     */
    public void setExpiryDate(LocalDateTime expiresAt) {
        this.expiresAt = expiresAt;
    }

    /**
     * Checks if the notification is expired
     */
    public boolean isExpired() {
        return expiresAt != null && LocalDateTime.now().isAfter(expiresAt);
    }
}
==> ./src/main/java/com/p2pfinance/notification/domain/DeliveryStatus.java <==
package com.p2pfinance.notification.domain;

/**
 * Represents the delivery status of a notification
 */
public enum DeliveryStatus {
    PENDING,    // Notification is waiting to be delivered
    SENT,       // Notification has been sent
    DELIVERED,  // Notification has been delivered
    FAILED      // Notification delivery failed
}

==> ./src/main/java/com/p2pfinance/notification/NotificationServiceApplication.java <==
package com.p2pfinance.notification;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableJpaRepositories
@EnableFeignClients
@EnableCaching
@EnableScheduling
public class NotificationServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(NotificationServiceApplication.class, args);
    }
}
==> ./src/main/java/com/p2pfinance/notification/messaging/NotificationEventListener.java <==
package com.p2pfinance.notification.messaging;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.p2pfinance.notification.dto.SendNotificationRequest;
import com.p2pfinance.notification.event.*;
import com.p2pfinance.notification.service.NotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;

@Component
@RequiredArgsConstructor
@Slf4j
public class NotificationEventListener {
    private final NotificationService notificationService;
    private final ObjectMapper objectMapper;

    // User event listeners

    @KafkaListener(topics = "user-events", groupId = "notification-service")
    public void consumeUserEvents(String message) {
        try {
            // Determine the event type
            NotificationEvent baseEvent = objectMapper.readValue(message, NotificationEvent.class);

            switch (baseEvent.getEventType()) {
                case "USER_REGISTERED" -> handleUserRegisteredEvent(message);
                case "USER_VERIFIED" -> handleUserVerifiedEvent(message);
                default -> log.warn("Unknown user event type: {}", baseEvent.getEventType());
            }
        } catch (Exception e) {
            log.error("Error processing user event", e);
        }
    }

    private void handleUserRegisteredEvent(String message) throws Exception {
        UserRegisteredEvent event = objectMapper.readValue(message, UserRegisteredEvent.class);
        log.info("Received user registered event for user: {}", event.getUserId());

        Map<String, Object> params = new HashMap<>();
        params.put("username", event.getUsername());

        SendNotificationRequest request = SendNotificationRequest.builder()
                .userId(event.getUserId())
                .templateCode("user_registered")
                .parameters(params)
                .types(new String[]{"EMAIL"}) // Force email notification for registration
                .build();

        notificationService.sendNotification(request);
    }

    private void handleUserVerifiedEvent(String message) throws Exception {
        UserVerifiedEvent event = objectMapper.readValue(message, UserVerifiedEvent.class);
        log.info("Received user verified event for user: {}", event.getUserId());

        Map<String, Object> params = new HashMap<>();
        params.put("username", event.getUsername());

        SendNotificationRequest request = SendNotificationRequest.builder()
                .userId(event.getUserId())
                .templateCode("user_verified")
                .parameters(params)
                .build();

        notificationService.sendNotification(request);
    }

    // Wallet event listeners

    @KafkaListener(topics = "wallet-events", groupId = "notification-service")
    public void consumeWalletEvents(String message) {
        try {
            // Determine the event type
            NotificationEvent baseEvent = objectMapper.readValue(message, NotificationEvent.class);

            if ("WALLET_TRANSACTION".equals(baseEvent.getEventType())) {
                handleWalletTransactionEvent(message);
            } else {
                log.warn("Unknown wallet event type: {}", baseEvent.getEventType());
            }
        } catch (Exception e) {
            log.error("Error processing wallet event", e);
        }
    }

    private void handleWalletTransactionEvent(String message) throws Exception {
        WalletTransactionEvent event = objectMapper.readValue(message, WalletTransactionEvent.class);
        log.info("Received wallet transaction event for user: {}, type: {}",
                event.getUserId(), event.getTransactionType());

        String templateCode;
        switch (event.getTransactionType()) {
            case "DEPOSIT" -> templateCode = "wallet_deposit";
            case "WITHDRAWAL" -> templateCode = "wallet_withdrawal";
            case "TRANSFER" -> templateCode = "wallet_transfer";
            default -> {
                log.warn("Unknown transaction type: {}", event.getTransactionType());
                return;
            }
        }

        Map<String, Object> params = new HashMap<>();
        params.put("amount", event.getAmount());
        params.put("currency", event.getCurrency());
        params.put("newBalance", event.getNewBalance());

        if (event.getCounterpartyName() != null) {
            params.put("counterpartyName", event.getCounterpartyName());
        }

        SendNotificationRequest request = SendNotificationRequest.builder()
                .userId(event.getUserId())
                .templateCode(templateCode)
                .parameters(params)
                .referenceId(event.getTransactionId().toString())
                .build();

        notificationService.sendNotification(request);
    }

    // Payment request event listeners

    @KafkaListener(topics = "payment-request-events", groupId = "notification-service")
    public void consumePaymentRequestEvents(String message) {
        try {
            // Determine the event type
            NotificationEvent baseEvent = objectMapper.readValue(message, NotificationEvent.class);

            if ("PAYMENT_REQUEST".equals(baseEvent.getEventType())) {
                handlePaymentRequestEvent(message);
            } else {
                log.warn("Unknown payment request event type: {}", baseEvent.getEventType());
            }
        } catch (Exception e) {
            log.error("Error processing payment request event", e);
        }
    }

    private void handlePaymentRequestEvent(String message) throws Exception {
        PaymentRequestEvent event = objectMapper.readValue(message, PaymentRequestEvent.class);
        log.info("Received payment request event for user: {}, status: {}",
                event.getUserId(), event.getStatus());

        String templateCode;
        switch (event.getStatus()) {
            case "CREATED" -> templateCode = "payment_request_created";
            case "APPROVED" -> templateCode = "payment_request_approved";
            case "REJECTED" -> templateCode = "payment_request_rejected";
            case "CANCELED" -> templateCode = "payment_request_canceled";
            case "EXPIRED" -> templateCode = "payment_request_expired";
            default -> {
                log.warn("Unknown payment request status: {}", event.getStatus());
                return;
            }
        }

        Map<String, Object> params = new HashMap<>();
        params.put("amount", event.getAmount());
        params.put("currency", event.getCurrency());

        if (event.getRequestorName() != null) {
            params.put("requestorName", event.getRequestorName());
        }

        if (event.getRecipientName() != null) {
            params.put("recipientName", event.getRecipientName());
        }

        SendNotificationRequest request = SendNotificationRequest.builder()
                .userId(event.getUserId())
                .templateCode(templateCode)
                .parameters(params)
                .referenceId(event.getRequestId().toString())
                .build();

        notificationService.sendNotification(request);
    }

    // Scheduled payment event listeners

    @KafkaListener(topics = "scheduled-payment-events", groupId = "notification-service")
    public void consumeScheduledPaymentEvents(String message) {
        try {
            // Determine the event type
            NotificationEvent baseEvent = objectMapper.readValue(message, NotificationEvent.class);

            if ("SCHEDULED_PAYMENT".equals(baseEvent.getEventType())) {
                handleScheduledPaymentEvent(message);
            } else {
                log.warn("Unknown scheduled payment event type: {}", baseEvent.getEventType());
            }
        } catch (Exception e) {
            log.error("Error processing scheduled payment event", e);
        }
    }

    private void handleScheduledPaymentEvent(String message) throws Exception {
        ScheduledPaymentEvent event = objectMapper.readValue(message, ScheduledPaymentEvent.class);
        log.info("Received scheduled payment event for user: {}, status: {}",
                event.getUserId(), event.getStatus());

        String templateCode;
        switch (event.getStatus()) {
            case "CREATED" -> templateCode = "scheduled_payment_created";
            case "EXECUTED" -> templateCode = "scheduled_payment_executed";
            case "FAILED" -> templateCode = "scheduled_payment_failed";
            case "COMPLETED" -> templateCode = "scheduled_payment_completed";
            case "CANCELED" -> templateCode = "scheduled_payment_canceled";
            default -> {
                log.warn("Unknown scheduled payment status: {}", event.getStatus());
                return;
            }
        }

        Map<String, Object> params = new HashMap<>();
        params.put("amount", event.getAmount());
        params.put("currency", event.getCurrency());

        if (event.getExecutionDate() != null) {
            params.put("executionDate", event.getExecutionDate());
        }

        if (event.getSenderName() != null) {
            params.put("senderName", event.getSenderName());
        }

        if (event.getRecipientName() != null) {
            params.put("recipientName", event.getRecipientName());
        }

        SendNotificationRequest request = SendNotificationRequest.builder()
                .userId(event.getUserId())
                .templateCode(templateCode)
                .parameters(params)
                .referenceId(event.getPaymentId().toString())
                .build();

        notificationService.sendNotification(request);
    }

    // Split payment event listeners

    @KafkaListener(topics = "split-payment-events", groupId = "notification-service")
    public void consumeSplitPaymentEvents(String message) {
        try {
            // Determine the event type
            NotificationEvent baseEvent = objectMapper.readValue(message, NotificationEvent.class);

            if ("SPLIT_PAYMENT".equals(baseEvent.getEventType())) {
                handleSplitPaymentEvent(message);
            } else {
                log.warn("Unknown split payment event type: {}", baseEvent.getEventType());
            }
        } catch (Exception e) {
            log.error("Error processing split payment event", e);
        }
    }

    private void handleSplitPaymentEvent(String message) throws Exception {
        SplitPaymentEvent event = objectMapper.readValue(message, SplitPaymentEvent.class);
        log.info("Received split payment event for user: {}, status: {}",
                event.getUserId(), event.getStatus());

        String templateCode;
        switch (event.getStatus()) {
            case "CREATED" -> templateCode = "split_payment_created";
            case "PARTICIPANT_ADDED" -> templateCode = "split_payment_participant_added";
            case "PARTICIPANT_PAID" -> templateCode = "split_payment_participant_paid";
            case "COMPLETED" -> templateCode = "split_payment_completed";
            case "CANCELED" -> templateCode = "split_payment_canceled";
            default -> {
                log.warn("Unknown split payment status: {}", event.getStatus());
                return;
            }
        }

        Map<String, Object> params = new HashMap<>();
        params.put("title", event.getTitle());
        params.put("totalAmount", event.getTotalAmount());
        params.put("currency", event.getCurrency());

        if (event.getUserAmount() != null) {
            params.put("userAmount", event.getUserAmount());
        }

        if (event.getOrganizerName() != null) {
            params.put("organizerName", event.getOrganizerName());
        }

        if (event.getParticipantName() != null) {
            params.put("participantName", event.getParticipantName());
        }

        SendNotificationRequest request = SendNotificationRequest.builder()
                .userId(event.getUserId())
                .templateCode(templateCode)
                .parameters(params)
                .referenceId(event.getPaymentId().toString())
                .build();

        notificationService.sendNotification(request);
    }

    // Security event listeners

    @KafkaListener(topics = "security-events", groupId = "notification-service")
    public void consumeSecurityEvents(String message) {
        try {
            // Determine the event type
            NotificationEvent baseEvent = objectMapper.readValue(message, NotificationEvent.class);

            if ("SECURITY".equals(baseEvent.getEventType())) {
                handleSecurityEvent(message);
            } else {
                log.warn("Unknown security event type: {}", baseEvent.getEventType());
            }
        } catch (Exception e) {
            log.error("Error processing security event", e);
        }
    }

    private void handleSecurityEvent(String message) throws Exception {
        SecurityEvent event = objectMapper.readValue(message, SecurityEvent.class);
        log.info("Received security event for user: {}, type: {}",
                event.getUserId(), event.getSecurityEventType());

        String templateCode;
        switch (event.getSecurityEventType()) {
            case "LOGIN" -> templateCode = "security_login";
            case "PASSWORD_CHANGED" -> templateCode = "security_password_changed";
            case "DEVICE_ADDED" -> templateCode = "security_device_added";
            case "SUSPICIOUS_ACTIVITY" -> templateCode = "security_suspicious_activity";
            default -> {
                log.warn("Unknown security event type: {}", event.getSecurityEventType());
                return;
            }
        }

        Map<String, Object> params = new HashMap<>();
        params.put("eventTime", event.getEventTime());

        if (event.getIpAddress() != null) {
            params.put("ipAddress", event.getIpAddress());
        }

        if (event.getDeviceInfo() != null) {
            params.put("deviceInfo", event.getDeviceInfo());
        }

        if (event.getLocation() != null) {
            params.put("location", event.getLocation());
        }

        // For suspicious activities, always send via email too
        String[] types = event.isSuspicious() ?
                new String[]{"APP", "EMAIL"} : null;

        SendNotificationRequest request = SendNotificationRequest.builder()
                .userId(event.getUserId())
                .templateCode(templateCode)
                .parameters(params)
                .types(types)
                .build();

        notificationService.sendNotification(request);
    }
}
==> ./src/main/java/com/p2pfinance/notification/api/NotificationPreferencesController.java <==
package com.p2pfinance.notification.api;

import com.p2pfinance.notification.dto.NotificationPreferencesResponse;
import com.p2pfinance.notification.dto.UpdatePreferencesRequest;
import com.p2pfinance.notification.service.NotificationPreferencesService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/api/v1/notifications/preferences")
@RequiredArgsConstructor
@Slf4j
public class NotificationPreferencesController {
    private final NotificationPreferencesService preferencesService;

    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<NotificationPreferencesResponse> getPreferences(
            @AuthenticationPrincipal UserDetails userDetails) {
        log.info("Get notification preferences request received");

        UUID userId = getUserIdFromUserDetails(userDetails);
        return ResponseEntity.ok(preferencesService.getPreferences(userId));
    }

    @PutMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<NotificationPreferencesResponse> updatePreferences(
            @AuthenticationPrincipal UserDetails userDetails,
            @Valid @RequestBody UpdatePreferencesRequest request) {
        log.info("Update notification preferences request received");

        UUID userId = getUserIdFromUserDetails(userDetails);
        return ResponseEntity.ok(preferencesService.updatePreferences(userId, request));
    }

    @PostMapping("/device-token")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Void> updateDeviceToken(
            @AuthenticationPrincipal UserDetails userDetails,
            @RequestBody String deviceToken) {
        log.info("Update device token request received");

        UUID userId = getUserIdFromUserDetails(userDetails);
        preferencesService.updateDeviceToken(userId, deviceToken);

        return ResponseEntity.ok().build();
    }

    /**
     * Helper method to extract user ID from UserDetails
     */
    private UUID getUserIdFromUserDetails(UserDetails userDetails) {
        return UUID.fromString(userDetails.getUsername());
    }
}
==> ./src/main/java/com/p2pfinance/notification/api/NotificationTemplateController.java <==
package com.p2pfinance.notification.api;

import com.p2pfinance.notification.dto.NotificationTemplateRequest;
import com.p2pfinance.notification.dto.NotificationTemplateResponse;
import com.p2pfinance.notification.service.NotificationTemplateService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/notifications/templates")
@RequiredArgsConstructor
@Slf4j
public class NotificationTemplateController {
    private final NotificationTemplateService templateService;

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<NotificationTemplateResponse> createTemplate(
            @Valid @RequestBody NotificationTemplateRequest request) {
        log.info("Create notification template request received");
        return ResponseEntity.ok(templateService.createTemplate(request));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<NotificationTemplateResponse> updateTemplate(
            @PathVariable UUID id,
            @Valid @RequestBody NotificationTemplateRequest request) {
        log.info("Update notification template request received for ID: {}", id);
        return ResponseEntity.ok(templateService.updateTemplate(id, request));
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<NotificationTemplateResponse> getTemplate(@PathVariable UUID id) {
        log.info("Get notification template request received for ID: {}", id);
        return ResponseEntity.ok(templateService.getTemplateById(id));
    }

    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<NotificationTemplateResponse>> getAllTemplates() {
        log.info("Get all notification templates request received");
        return ResponseEntity.ok(templateService.getAllTemplates());
    }

    @GetMapping("/category/{category}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<NotificationTemplateResponse>> getTemplatesByCategory(
            @PathVariable String category) {
        log.info("Get notification templates request received for category: {}", category);
        return ResponseEntity.ok(templateService.getTemplatesByCategory(category));
    }

    @PostMapping("/{id}/enable")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<NotificationTemplateResponse> enableTemplate(@PathVariable UUID id) {
        log.info("Enable notification template request received for ID: {}", id);
        return ResponseEntity.ok(templateService.setTemplateEnabled(id, true));
    }

    @PostMapping("/{id}/disable")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<NotificationTemplateResponse> disableTemplate(@PathVariable UUID id) {
        log.info("Disable notification template request received for ID: {}", id);
        return ResponseEntity.ok(templateService.setTemplateEnabled(id, false));
    }
}
==> ./src/main/java/com/p2pfinance/notification/api/NotificationController.java <==
package com.p2pfinance.notification.api;

import com.p2pfinance.notification.dto.NotificationListResponse;
import com.p2pfinance.notification.dto.NotificationResponse;
import com.p2pfinance.notification.dto.SendNotificationRequest;
import com.p2pfinance.notification.service.NotificationService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/notifications")
@RequiredArgsConstructor
@Slf4j
public class NotificationController {
    private final NotificationService notificationService;

    @PostMapping("/send")
    public ResponseEntity<List<NotificationResponse>> sendNotification(
            @Valid @RequestBody SendNotificationRequest request) {
        log.info("Send notification request received");
        return ResponseEntity.ok(notificationService.sendNotification(request));
    }

    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<NotificationListResponse> getNotifications(
            @AuthenticationPrincipal UserDetails userDetails,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        log.info("Get notifications request received");

        UUID userId = getUserIdFromUserDetails(userDetails);
        Pageable pageable = PageRequest.of(page, size, Sort.by("createdAt").descending());

        return ResponseEntity.ok(notificationService.getNotifications(userId, pageable));
    }

    @GetMapping("/unread")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<NotificationListResponse> getUnreadNotifications(
            @AuthenticationPrincipal UserDetails userDetails,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        log.info("Get unread notifications request received");

        UUID userId = getUserIdFromUserDetails(userDetails);
        Pageable pageable = PageRequest.of(page, size, Sort.by("createdAt").descending());

        return ResponseEntity.ok(notificationService.getUnreadNotifications(userId, pageable));
    }

    @GetMapping("/{id}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<NotificationResponse> getNotification(@PathVariable UUID id) {
        log.info("Get notification request received for ID: {}", id);
        return ResponseEntity.ok(notificationService.getNotification(id));
    }

    @PostMapping("/{id}/read")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<NotificationResponse> markAsRead(@PathVariable UUID id) {
        log.info("Mark notification as read request received for ID: {}", id);
        return ResponseEntity.ok(notificationService.markAsRead(id));
    }

    @PostMapping("/read-all")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Void> markAllAsRead(@AuthenticationPrincipal UserDetails userDetails) {
        log.info("Mark all notifications as read request received");

        UUID userId = getUserIdFromUserDetails(userDetails);
        notificationService.markAllAsRead(userId);

        return ResponseEntity.ok().build();
    }

    /**
     * Helper method to extract user ID from UserDetails
     */
    private UUID getUserIdFromUserDetails(UserDetails userDetails) {
        return UUID.fromString(userDetails.getUsername());
    }
}
==> ./src/main/java/com/p2pfinance/notification/dto/NotificationListResponse.java <==
package com.p2pfinance.notification.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List; /**
 * Response for notification list operations
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NotificationListResponse {
    private List<NotificationResponse> notifications;
    private long unreadCount;
    private int totalPages;
    private long totalElements;
    private int page;
    private int size;
}

==> ./src/main/java/com/p2pfinance/notification/dto/NotificationPreferencesResponse.java <==
package com.p2pfinance.notification.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID; /**
 * Response for notification preferences
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NotificationPreferencesResponse {
    private UUID userId;
    private boolean appNotificationsEnabled;
    private boolean emailNotificationsEnabled;
    private boolean smsNotificationsEnabled;
    private boolean pushNotificationsEnabled;
    private Map<String, Boolean> categoryPreferences;
    private Integer quietHoursStart;
    private Integer quietHoursEnd;
    private String email;
    private String phoneNumber;
    private boolean deviceTokenRegistered;
    private LocalDateTime updatedAt;
}

==> ./src/main/java/com/p2pfinance/notification/dto/SendNotificationRequest.java <==
package com.p2pfinance.notification.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID; /**
 * Request to send a notification
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SendNotificationRequest {
    @NotNull(message = "User ID is required")
    private UUID userId;

    @NotBlank(message = "Template code is required")
    private String templateCode;

    // Parameters for the template
    private Map<String, Object> parameters;

    // Types of notification to send (if not specified, sends based on user preferences)
    private String[] types;

    // Optional reference ID for tracking
    private String referenceId;

    // Optional action URL
    private String actionUrl;

    // Optional expiry date
    private LocalDateTime expiresAt;
}

==> ./src/main/java/com/p2pfinance/notification/dto/NotificationTemplateResponse.java <==
package com.p2pfinance.notification.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID; /**
 * Response for notification template operations
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NotificationTemplateResponse {
    private UUID id;
    private String code;
    private String name;
    private String category;
    private String titleTemplate;
    private String messageTemplate;
    private String emailSubjectTemplate;
    private String emailBodyTemplate;
    private String smsTemplate;
    private String actionUrlTemplate;
    private boolean enabled;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}

==> ./src/main/java/com/p2pfinance/notification/dto/NotificationResponse.java <==
package com.p2pfinance.notification.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID; /**
 * Response for notification operations
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NotificationResponse {
    private UUID id;
    private UUID userId;
    private String title;
    private String message;
    private String type;
    private String category;
    private String referenceId;
    private boolean read;
    private String actionUrl;
    private LocalDateTime createdAt;
    private LocalDateTime expiresAt;
    private LocalDateTime readAt;
    private String deliveryStatus;
}

==> ./src/main/java/com/p2pfinance/notification/dto/NotificationTemplateRequest.java <==
package com.p2pfinance.notification.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor; /**
 * Request to create or update a notification template
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NotificationTemplateRequest {
    @NotBlank(message = "Code is required")
    @Size(max = 100, message = "Code cannot exceed 100 characters")
    private String code;

    @NotBlank(message = "Name is required")
    @Size(max = 100, message = "Name cannot exceed 100 characters")
    private String name;

    @NotBlank(message = "Category is required")
    @Size(max = 100, message = "Category cannot exceed 100 characters")
    private String category;

    @NotBlank(message = "Title template is required")
    @Size(max = 200, message = "Title template cannot exceed 200 characters")
    private String titleTemplate;

    @NotBlank(message = "Message template is required")
    @Size(max = 2000, message = "Message template cannot exceed 2000 characters")
    private String messageTemplate;

    @Size(max = 2000, message = "Email subject template cannot exceed 2000 characters")
    private String emailSubjectTemplate;

    @Size(max = 5000, message = "Email body template cannot exceed 5000 characters")
    private String emailBodyTemplate;

    @Size(max = 200, message = "SMS template cannot exceed 200 characters")
    private String smsTemplate;

    @Size(max = 500, message = "Action URL template cannot exceed 500 characters")
    private String actionUrlTemplate;

    private boolean enabled;
}

==> ./src/main/java/com/p2pfinance/notification/dto/UpdatePreferencesRequest.java <==
package com.p2pfinance.notification.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * Request to update notification preferences
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UpdatePreferencesRequest {
    private Boolean appNotificationsEnabled;
    private Boolean emailNotificationsEnabled;
    private Boolean smsNotificationsEnabled;
    private Boolean pushNotificationsEnabled;
    private Map<String, Boolean> categoryPreferences;
    private Integer quietHoursStart;
    private Integer quietHoursEnd;
    private String email;
    private String phoneNumber;
    private String deviceToken;
}

