# PROJECT ANALYSIS FOR AI ASSISTANT

## 📦 GENERAL INFORMATION

- **Project path**: `/media/psf/Home/git/waqiti-app/services/notification-service`
- **Total files**: 65
- **Files included in this analysis**: 46
- **Main languages used**:
  - Java (40 files)
  - SQL (2 files)
  - Shell (1 files)
  - XML (1 files)
  - YAML (1 files)

## 🗂️ PROJECT STRUCTURE

```
/media/psf/Home/git/waqiti-app/services/notification-service
    ├── logs
    │   └── notification-service.log
    ├── src
    │   ├── main
    │   │   ├── java
    │   │   │   └── com
    │   │   │       ├── p2pfinance
    │   │   │       └── waqiti
    │   │   │           └── notification
    │   │   │               ├── api
    │   │   │               │   ├── NotificationController.java
    │   │   │               │   ├── NotificationPreferencesController.java
    │   │   │               │   ├── NotificationTemplateController.java
    │   │   │               │   └── TwoFactorNotificationController.java
    │   │   │               ├── config
    │   │   │               │   ├── FirebaseConfig.java
    │   │   │               │   └── KafkaConsumerConfig.java
    │   │   │               ├── domain
    │   │   │               │   ├── DeliveryStatus.java
    │   │   │               │   ├── Notification.java
    │   │   │               │   ├── NotificationCategory.java
    │   │   │               │   ├── NotificationPreferences.java
    │   │   │               │   ├── NotificationTemplate.java
    │   │   │               │   └── NotificationType.java
    │   │   │               ├── dto
    │   │   │               │   ├── NotificationListResponse.java
    │   │   │               │   ├── NotificationPreferencesResponse.java
    │   │   │               │   ├── NotificationResponse.java
    │   │   │               │   ├── NotificationTemplateRequest.java
    │   │   │               │   ├── NotificationTemplateResponse.java
    │   │   │               │   ├── SendNotificationRequest.java
    │   │   │               │   ├── TwoFactorNotificationRequest.java
    │   │   │               │   └── UpdatePreferencesRequest.java
    │   │   │               ├── event
    │   │   │               │   ├── NotificationEvent.java
    │   │   │               │   ├── PaymentRequestEvent.java
    │   │   │               │   ├── ScheduledPaymentEvent.java
    │   │   │               │   ├── SecurityEvent.java
    │   │   │               │   ├── SplitPaymentEvent.java
    │   │   │               │   ├── UserRegisteredEvent.java
    │   │   │               │   ├── UserVerifiedEvent.java
    │   │   │               │   └── WalletTransactionEvent.java
    │   │   │               ├── messaging
    │   │   │               │   └── NotificationEventListener.java
    │   │   │               ├── repository
    │   │   │               │   ├── NotificationPreferencesRepository.java
    │   │   │               │   ├── NotificationRepository.java
    │   │   │               │   └── NotificationTemplateRepository.java
    │   │   │               ├── service
    │   │   │               │   ├── provider
    │   │   │               │   │   └── SmsProvider.java
    │   │   │               │   ├── NotificationPreferencesService.java
    │   │   │               │   ├── NotificationSenderService.java
    │   │   │               │   ├── NotificationService.java
    │   │   │               │   ├── NotificationTemplateService.java
    │   │   │               │   ├── TemplateRenderer.java
    │   │   │               │   └── TwoFactorNotificationService.java
    │   │   │               └── NotificationServiceApplication.java
    │   │   └── resources
    │   │       ├── db
    │   │       │   └── migration
    │   │       │       ├── V1__create_notification_tables.sql
    │   │       │       └── V2__add_2fa_templates.sql
    │   │       └── application.yml
    │   └── test
    │       ├── java
    │       │   └── com
    │       │       ├── p2pfinance
    │       │       └── waqiti
    │       │           └── notification
    │       │               ├── api
    │       │               │   └── NotificationControllerTest.java
    │       │               ├── config
    │       │               │   ├── NotificationTestConfig.java
    │       │               │   └── TestFirebaseConfig.java
    │       │               ├── messaging
    │       │               │   ├── NotificationEventListenerTest.java
    │       │               │   └── NotificationKafkaIntegrationTest.java
    │       │               ├── repository
    │       │               │   ├── JpaTestConfig.java
    │       │               │   ├── NotificationRepositoryTest.java
    │       │               │   └── NotificationTemplateRepositoryTest.java
    │       │               ├── service
    │       │               │   ├── NotificationPreferencesServiceTest.java
    │       │               │   ├── NotificationSenderServiceTest.java
    │       │               │   ├── NotificationServiceIntegrationTest.java
    │       │               │   ├── NotificationServiceTest.java
    │       │               │   ├── NotificationTemplateServiceTest.java
    │       │               │   └── TemplateRendererTest.java
    │       │               ├── NotificationE2ETest.java
    │       │               └── TestcontainersBase.java
    │       └── resources
    │           └── application-test.yml
    ├── Dockerfile
    ├── notification-service.llm
    ├── pom.xml
    └── run-tests.sh
```

### 📂 Main Components

- **`logs/`** - 
- **`src/`** - 

## 🔄 FILE RELATIONSHIPS

### Core Files (most referenced)

- **`notification-service/src/main/java/com/waqiti/notification/domain/NotificationType.java`** is imported by 10 files
- **`notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java`** is imported by 9 files
- **`notification-service/src/main/java/com/waqiti/notification/domain/Notification.java`** is imported by 9 files
- **`notification-service/src/main/java/com/waqiti/notification/dto/SendNotificationRequest.java`** is imported by 7 files
- **`notification-service/src/main/java/com/waqiti/notification/repository/NotificationRepository.java`** is imported by 6 files
- **`notification-service/src/main/java/com/waqiti/notification/domain/NotificationPreferences.java`** is imported by 6 files
- **`notification-service/src/main/java/com/waqiti/notification/repository/NotificationPreferencesRepository.java`** is imported by 6 files
- **`notification-service/src/main/java/com/waqiti/notification/repository/NotificationTemplateRepository.java`** is imported by 5 files
- **`notification-service/src/main/java/com/waqiti/notification/domain/DeliveryStatus.java`** is imported by 5 files
- **`notification-service/src/main/java/com/waqiti/notification/service/NotificationService.java`** is imported by 5 files

### Dependencies by File

- **`notification-service/run-tests.sh`**:
  - *External dependencies*: `Please start Docker and try again.${NC}`
- **`notification-service/src/main/java/com/waqiti/notification/NotificationServiceApplication.java`**:
  - *External dependencies*: `org.springframework.boot.SpringApplication`, `org.springframework.boot.autoconfigure.SpringBootApplication`, `org.springframework.cache.annotation.EnableCaching`, `org.springframework.cloud.openfeign.EnableFeignClients`, `org.springframework.data.jpa.repository.config.EnableJpaRepositories` and 1 more
- **`notification-service/src/main/java/com/waqiti/notification/api/NotificationController.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/dto/NotificationListResponse.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationResponse.java`, `notification-service/src/main/java/com/waqiti/notification/dto/SendNotificationRequest.java`, `notification-service/src/main/java/com/waqiti/notification/service/NotificationService.java`
  - *External dependencies*: `jakarta.validation.Valid`, `java.util.List`, `java.util.UUID`, `lombok.RequiredArgsConstructor`, `lombok.extern.slf4j.Slf4j` and 8 more
- **`notification-service/src/main/java/com/waqiti/notification/api/NotificationPreferencesController.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/dto/NotificationPreferencesResponse.java`, `notification-service/src/main/java/com/waqiti/notification/dto/UpdatePreferencesRequest.java`, `notification-service/src/main/java/com/waqiti/notification/service/NotificationPreferencesService.java`
  - *External dependencies*: `jakarta.validation.Valid`, `java.util.UUID`, `lombok.RequiredArgsConstructor`, `lombok.extern.slf4j.Slf4j`, `org.springframework.http.ResponseEntity` and 4 more
- **`notification-service/src/main/java/com/waqiti/notification/api/NotificationTemplateController.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/dto/NotificationTemplateRequest.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationTemplateResponse.java`, `notification-service/src/main/java/com/waqiti/notification/service/NotificationTemplateService.java`
  - *External dependencies*: `jakarta.validation.Valid`, `java.util.List`, `java.util.UUID`, `lombok.RequiredArgsConstructor`, `lombok.extern.slf4j.Slf4j` and 3 more
- **`notification-service/src/main/java/com/waqiti/notification/api/TwoFactorNotificationController.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/dto/TwoFactorNotificationRequest.java`, `notification-service/src/main/java/com/waqiti/notification/service/TwoFactorNotificationService.java`
  - *External dependencies*: `jakarta.validation.Valid`, `java.util.UUID`, `lombok.RequiredArgsConstructor`, `lombok.extern.slf4j.Slf4j`, `org.springframework.http.ResponseEntity` and 2 more
- **`notification-service/src/main/java/com/waqiti/notification/config/FirebaseConfig.java`**:
  - *External dependencies*: `com.google.auth.oauth2.GoogleCredentials`, `com.google.firebase.FirebaseApp`, `com.google.firebase.FirebaseOptions`, `com.google.firebase.messaging.FirebaseMessaging`, `java.io.IOException` and 7 more
- **`notification-service/src/main/java/com/waqiti/notification/config/KafkaConsumerConfig.java`**:
  - *External dependencies*: `java.util.HashMap`, `java.util.Map`, `lombok.extern.slf4j.Slf4j`, `org.apache.kafka.clients.consumer.ConsumerConfig`, `org.apache.kafka.common.serialization.StringDeserializer` and 10 more
- **`notification-service/src/main/java/com/waqiti/notification/domain/Notification.java`**:
  - *External dependencies*: `jakarta.persistence.`, `java.time.LocalDateTime`, `java.util.UUID`, `lombok.AccessLevel`, `lombok.Getter` and 2 more
- **`notification-service/src/main/java/com/waqiti/notification/domain/NotificationPreferences.java`**:
  - *External dependencies*: `jakarta.persistence.`, `java.time.LocalDateTime`, `java.util.HashMap`, `java.util.Map`, `java.util.UUID` and 4 more
- **`notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java`**:
  - *External dependencies*: `jakarta.persistence.`, `java.time.LocalDateTime`, `java.util.UUID`, `lombok.AccessLevel`, `lombok.Getter` and 2 more
- **`notification-service/src/main/java/com/waqiti/notification/dto/NotificationListResponse.java`**:
  - *External dependencies*: `com.fasterxml.jackson.annotation.JsonInclude`, `java.util.List`, `lombok.AllArgsConstructor`, `lombok.Builder`, `lombok.Data` and 1 more
- **`notification-service/src/main/java/com/waqiti/notification/dto/NotificationPreferencesResponse.java`**:
  - *External dependencies*: `com.fasterxml.jackson.annotation.JsonInclude`, `java.time.LocalDateTime`, `java.util.Map`, `java.util.UUID`, `lombok.AllArgsConstructor` and 3 more
- **`notification-service/src/main/java/com/waqiti/notification/dto/NotificationResponse.java`**:
  - *External dependencies*: `com.fasterxml.jackson.annotation.JsonInclude`, `java.time.LocalDateTime`, `java.util.UUID`, `lombok.AllArgsConstructor`, `lombok.Builder` and 2 more
- **`notification-service/src/main/java/com/waqiti/notification/dto/NotificationTemplateRequest.java`**:
  - *External dependencies*: `jakarta.validation.constraints.NotBlank`, `jakarta.validation.constraints.Size`, `lombok.AllArgsConstructor`, `lombok.Builder`, `lombok.Data` and 1 more
- **`notification-service/src/main/java/com/waqiti/notification/dto/NotificationTemplateResponse.java`**:
  - *External dependencies*: `com.fasterxml.jackson.annotation.JsonInclude`, `java.time.LocalDateTime`, `java.util.UUID`, `lombok.AllArgsConstructor`, `lombok.Builder` and 2 more
- **`notification-service/src/main/java/com/waqiti/notification/dto/SendNotificationRequest.java`**:
  - *External dependencies*: `jakarta.validation.constraints.NotBlank`, `jakarta.validation.constraints.NotNull`, `java.time.LocalDateTime`, `java.util.Map`, `java.util.UUID` and 4 more
- **`notification-service/src/main/java/com/waqiti/notification/dto/TwoFactorNotificationRequest.java`**:
  - *External dependencies*: `jakarta.validation.constraints.NotBlank`, `jakarta.validation.constraints.NotNull`, `java.util.UUID`, `lombok.AllArgsConstructor`, `lombok.Builder` and 2 more
- **`notification-service/src/main/java/com/waqiti/notification/dto/UpdatePreferencesRequest.java`**:
  - *External dependencies*: `com.fasterxml.jackson.annotation.JsonInclude`, `jakarta.validation.constraints.NotBlank`, `jakarta.validation.constraints.NotNull`, `jakarta.validation.constraints.Size`, `java.time.LocalDateTime` and 7 more
- **`notification-service/src/main/java/com/waqiti/notification/event/NotificationEvent.java`**:
  - *External dependencies*: `java.time.LocalDateTime`, `java.util.UUID`, `lombok.Data`
- **`notification-service/src/main/java/com/waqiti/notification/event/PaymentRequestEvent.java`**:
  - *External dependencies*: `java.math.BigDecimal`, `java.util.UUID`, `lombok.AllArgsConstructor`, `lombok.Builder`, `lombok.Data` and 2 more
- **`notification-service/src/main/java/com/waqiti/notification/event/ScheduledPaymentEvent.java`**:
  - *External dependencies*: `java.math.BigDecimal`, `java.time.LocalDateTime`, `java.util.UUID`, `lombok.AllArgsConstructor`, `lombok.Builder` and 3 more
- **`notification-service/src/main/java/com/waqiti/notification/event/SecurityEvent.java`**:
  - *External dependencies*: `java.time.LocalDateTime`, `java.util.UUID`, `lombok.AllArgsConstructor`, `lombok.Builder`, `lombok.Data` and 2 more
- **`notification-service/src/main/java/com/waqiti/notification/event/SplitPaymentEvent.java`**:
  - *External dependencies*: `java.math.BigDecimal`, `java.util.UUID`, `lombok.AllArgsConstructor`, `lombok.Builder`, `lombok.Data` and 2 more
- **`notification-service/src/main/java/com/waqiti/notification/event/UserRegisteredEvent.java`**:
  - *External dependencies*: `java.util.UUID`, `javax.annotation.PostConstruct`, `lombok.AllArgsConstructor`, `lombok.Builder`, `lombok.Data` and 2 more
- **`notification-service/src/main/java/com/waqiti/notification/event/UserVerifiedEvent.java`**:
  - *External dependencies*: `java.util.UUID`, `javax.annotation.PostConstruct`, `lombok.AllArgsConstructor`, `lombok.Builder`, `lombok.Data` and 2 more
- **`notification-service/src/main/java/com/waqiti/notification/event/WalletTransactionEvent.java`**:
  - *External dependencies*: `java.math.BigDecimal`, `java.util.UUID`, `lombok.AllArgsConstructor`, `lombok.Builder`, `lombok.Data` and 2 more
- **`notification-service/src/main/java/com/waqiti/notification/messaging/NotificationEventListener.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/dto/SendNotificationRequest.java`, `notification-service/src/main/java/com/waqiti/notification/service/NotificationService.java`
  - *External dependencies*: `com.fasterxml.jackson.databind.ObjectMapper`, `com.waqiti.notification.event.`, `java.util.HashMap`, `java.util.Map`, `lombok.RequiredArgsConstructor` and 3 more
- **`notification-service/src/main/java/com/waqiti/notification/repository/NotificationPreferencesRepository.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/NotificationPreferences.java`
  - *External dependencies*: `java.util.List`, `java.util.UUID`, `org.springframework.data.jpa.repository.JpaRepository`, `org.springframework.data.jpa.repository.Query`, `org.springframework.data.repository.query.Param` and 1 more
- **`notification-service/src/main/java/com/waqiti/notification/repository/NotificationRepository.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/DeliveryStatus.java`, `notification-service/src/main/java/com/waqiti/notification/domain/Notification.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationType.java`
  - *External dependencies*: `java.time.LocalDateTime`, `java.util.List`, `java.util.UUID`, `org.springframework.data.domain.Page`, `org.springframework.data.domain.Pageable` and 4 more
- **`notification-service/src/main/java/com/waqiti/notification/repository/NotificationTemplateRepository.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java`
  - *External dependencies*: `java.util.List`, `java.util.Optional`, `java.util.UUID`, `org.springframework.data.jpa.repository.JpaRepository`, `org.springframework.stereotype.Repository`
- **`notification-service/src/main/java/com/waqiti/notification/service/NotificationPreferencesService.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/NotificationPreferences.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationType.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationPreferencesResponse.java`, `notification-service/src/main/java/com/waqiti/notification/dto/UpdatePreferencesRequest.java`, `notification-service/src/main/java/com/waqiti/notification/repository/NotificationPreferencesRepository.java`
  - *External dependencies*: `java.util.Map`, `java.util.UUID`, `lombok.RequiredArgsConstructor`, `lombok.extern.slf4j.Slf4j`, `org.springframework.stereotype.Service` and 1 more
- **`notification-service/src/main/java/com/waqiti/notification/service/NotificationSenderService.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/Notification.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationPreferences.java`, `notification-service/src/main/java/com/waqiti/notification/repository/NotificationPreferencesRepository.java`, `notification-service/src/main/java/com/waqiti/notification/service/provider/SmsProvider.java`
  - *External dependencies*: `com.google.firebase.messaging.FirebaseMessaging`, `com.google.firebase.messaging.FirebaseMessagingException`, `com.google.firebase.messaging.Message`, `jakarta.mail.internet.MimeMessage`, `java.util.HashMap` and 7 more
- **`notification-service/src/main/java/com/waqiti/notification/service/NotificationService.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/DeliveryStatus.java`, `notification-service/src/main/java/com/waqiti/notification/domain/Notification.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationType.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationListResponse.java` and 3 more
  - *External dependencies*: `com.waqiti.notification.domain.`, `java.time.LocalDateTime`, `java.util.`, `java.util.stream.Collectors`, `lombok.RequiredArgsConstructor` and 6 more
- **`notification-service/src/main/java/com/waqiti/notification/service/NotificationTemplateService.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationTemplateRequest.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationTemplateResponse.java`, `notification-service/src/main/java/com/waqiti/notification/repository/NotificationTemplateRepository.java`
  - *External dependencies*: `java.util.List`, `java.util.UUID`, `java.util.stream.Collectors`, `lombok.RequiredArgsConstructor`, `lombok.extern.slf4j.Slf4j` and 4 more
- **`notification-service/src/main/java/com/waqiti/notification/service/TemplateRenderer.java`**:
  - *External dependencies*: `java.util.Locale`, `java.util.Map`, `lombok.RequiredArgsConstructor`, `lombok.extern.slf4j.Slf4j`, `org.springframework.stereotype.Service` and 2 more
- **`notification-service/src/main/java/com/waqiti/notification/service/TwoFactorNotificationService.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/DeliveryStatus.java`, `notification-service/src/main/java/com/waqiti/notification/domain/Notification.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationType.java`, `notification-service/src/main/java/com/waqiti/notification/repository/NotificationRepository.java` and 1 more
  - *External dependencies*: `java.time.LocalDateTime`, `java.util.HashMap`, `java.util.Map`, `java.util.UUID`, `lombok.RequiredArgsConstructor` and 3 more
- **`notification-service/src/main/java/com/waqiti/notification/service/provider/SmsProvider.java`**:
  - *External dependencies*: `com.twilio.Twilio`, `com.twilio.rest.api.v2010.account.Message`, `com.twilio.type.PhoneNumber`, `lombok.extern.slf4j.Slf4j`, `org.springframework.beans.factory.annotation.Value` and 1 more
- **`notification-service/src/test/java/com/waqiti/notification/NotificationE2ETest.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/Notification.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationPreferences.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationType.java`, `notification-service/src/main/java/com/waqiti/notification/dto/UpdatePreferencesRequest.java` and 5 more
  - *External dependencies*: `com.fasterxml.jackson.databind.ObjectMapper`, `com.waqiti.notification.domain.`, `java.math.BigDecimal`, `java.util.List`, `java.util.UUID` and 16 more
- **`notification-service/src/test/java/com/waqiti/notification/TestcontainersBase.java`**:
  - *External dependencies*: `org.springframework.test.context.DynamicPropertyRegistry`, `org.springframework.test.context.DynamicPropertySource`, `org.testcontainers.containers.KafkaContainer`, `org.testcontainers.containers.PostgreSQLContainer`, `org.testcontainers.containers.wait.strategy.Wait` and 3 more
- **`notification-service/src/test/java/com/waqiti/notification/api/NotificationControllerTest.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/dto/NotificationListResponse.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationResponse.java`, `notification-service/src/main/java/com/waqiti/notification/dto/SendNotificationRequest.java`, `notification-service/src/main/java/com/waqiti/notification/service/NotificationService.java`
  - *External dependencies*: `com.fasterxml.jackson.databind.ObjectMapper`, `com.fasterxml.jackson.datatype.jsr310.JavaTimeModule`, `java.time.LocalDateTime`, `java.util.`, `org.junit.jupiter.api.BeforeEach` and 23 more
- **`notification-service/src/test/java/com/waqiti/notification/config/NotificationTestConfig.java`**:
  - *External dependencies*: `com.google.firebase.messaging.FirebaseMessaging`, `jakarta.persistence.EntityManagerFactory`, `java.util.Properties`, `org.mockito.Mockito`, `org.springframework.beans.factory.annotation.Qualifier` and 17 more
- **`notification-service/src/test/java/com/waqiti/notification/config/TestFirebaseConfig.java`**:
  - *External dependencies*: `com.google.firebase.messaging.FirebaseMessaging`, `com.google.firebase.messaging.Message`, `lombok.extern.slf4j.Slf4j`, `org.mockito.Mockito`, `org.springframework.context.annotation.Bean` and 3 more
- **`notification-service/src/test/java/com/waqiti/notification/messaging/NotificationEventListenerTest.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/dto/SendNotificationRequest.java`, `notification-service/src/main/java/com/waqiti/notification/service/NotificationService.java`
  - *External dependencies*: `com.fasterxml.jackson.databind.ObjectMapper`, `com.waqiti.notification.event.`, `java.math.BigDecimal`, `java.time.LocalDateTime`, `java.util.UUID` and 9 more
- **`notification-service/src/test/java/com/waqiti/notification/messaging/NotificationKafkaIntegrationTest.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/Notification.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationType.java`, `notification-service/src/main/java/com/waqiti/notification/event/PaymentRequestEvent.java`, `notification-service/src/main/java/com/waqiti/notification/event/UserRegisteredEvent.java` and 6 more
  - *External dependencies*: `com.fasterxml.jackson.databind.ObjectMapper`, `java.math.BigDecimal`, `java.util.List`, `java.util.UUID`, `java.util.concurrent.TimeUnit` and 12 more
- **`notification-service/src/test/java/com/waqiti/notification/repository/JpaTestConfig.java`**:
  - *External dependencies*: `jakarta.persistence.EntityManagerFactory`, `java.util.Properties`, `javax.sql.DataSource`, `org.springframework.boot.test.context.TestConfiguration`, `org.springframework.context.annotation.Bean` and 6 more
- **`notification-service/src/test/java/com/waqiti/notification/repository/NotificationRepositoryTest.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/DeliveryStatus.java`, `notification-service/src/main/java/com/waqiti/notification/domain/Notification.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationType.java`, `notification-service/src/test/java/com/waqiti/notification/TestcontainersBase.java`
  - *External dependencies*: `java.time.LocalDateTime`, `java.util.List`, `java.util.UUID`, `org.junit.jupiter.api.BeforeEach`, `org.junit.jupiter.api.Test` and 9 more
- **`notification-service/src/test/java/com/waqiti/notification/repository/NotificationTemplateRepositoryTest.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java`, `notification-service/src/test/java/com/waqiti/notification/TestcontainersBase.java`
  - *External dependencies*: `java.time.LocalDateTime`, `java.util.List`, `java.util.Optional`, `org.junit.jupiter.api.BeforeEach`, `org.junit.jupiter.api.Tag` and 6 more
- **`notification-service/src/test/java/com/waqiti/notification/service/NotificationPreferencesServiceTest.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/NotificationPreferences.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationType.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationPreferencesResponse.java`, `notification-service/src/main/java/com/waqiti/notification/dto/UpdatePreferencesRequest.java`, `notification-service/src/main/java/com/waqiti/notification/repository/NotificationPreferencesRepository.java`
  - *External dependencies*: `java.util.HashMap`, `java.util.Map`, `java.util.Optional`, `java.util.UUID`, `org.junit.jupiter.api.BeforeEach` and 8 more
- **`notification-service/src/test/java/com/waqiti/notification/service/NotificationSenderServiceTest.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/Notification.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationPreferences.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationType.java`, `notification-service/src/main/java/com/waqiti/notification/repository/NotificationPreferencesRepository.java`
  - *External dependencies*: `com.google.firebase.messaging.FirebaseMessaging`, `com.google.firebase.messaging.FirebaseMessagingException`, `com.google.firebase.messaging.Message`, `jakarta.mail.internet.MimeMessage`, `java.util.Optional` and 10 more
- **`notification-service/src/test/java/com/waqiti/notification/service/NotificationServiceIntegrationTest.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/dto/NotificationListResponse.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationResponse.java`, `notification-service/src/main/java/com/waqiti/notification/dto/SendNotificationRequest.java`, `notification-service/src/main/java/com/waqiti/notification/repository/NotificationPreferencesRepository.java`, `notification-service/src/main/java/com/waqiti/notification/repository/NotificationRepository.java` and 2 more
  - *External dependencies*: `com.waqiti.notification.domain.`, `java.time.LocalDateTime`, `java.util.HashMap`, `java.util.List`, `java.util.Map` and 13 more
- **`notification-service/src/test/java/com/waqiti/notification/service/NotificationServiceTest.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/DeliveryStatus.java`, `notification-service/src/main/java/com/waqiti/notification/domain/Notification.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationType.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationListResponse.java` and 3 more
  - *External dependencies*: `com.waqiti.notification.domain.`, `java.time.LocalDateTime`, `java.util.`, `org.junit.jupiter.api.BeforeEach`, `org.junit.jupiter.api.Tag` and 10 more
- **`notification-service/src/test/java/com/waqiti/notification/service/NotificationTemplateServiceTest.java`**:
  - *Internal dependencies*: `notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationTemplateRequest.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationTemplateResponse.java`, `notification-service/src/main/java/com/waqiti/notification/repository/NotificationTemplateRepository.java`
  - *External dependencies*: `java.util.`, `org.junit.jupiter.api.BeforeEach`, `org.junit.jupiter.api.Tag`, `org.junit.jupiter.api.Test`, `org.junit.jupiter.api.extension.ExtendWith` and 5 more
- **`notification-service/src/test/java/com/waqiti/notification/service/TemplateRendererTest.java`**:
  - *External dependencies*: `java.util.HashMap`, `java.util.Map`, `org.junit.jupiter.api.BeforeEach`, `org.junit.jupiter.api.Tag`, `org.junit.jupiter.api.Test` and 6 more

## 📄 FILE CONTENTS

*Note: The content below includes only selected files.*

### notification-service/run-tests.sh

**Dependencies:**
- External: `Please start Docker and try again.${NC}`

```sh
#!/bin/bash
# File: run-tests.sh
# Script to run different types of tests in the notification service

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print section header
print_header() {
    echo -e "\n${BLUE}===================================================${NC}"
    echo -e "${BLUE}   $1${NC}"
    echo -e "${BLUE}===================================================${NC}\n"
}

# Function to check if Docker is running
check_docker() {
    if ! docker info > /dev/null 2>&1; then
        echo -e "${RED}Error: Docker is not running. Please start Docker and try again.${NC}"
        exit 1
    fi
}

# Function to run unit tests
run_unit_tests() {
    print_header "Running Unit Tests"
    mvn test -DexcludedGroups=IntegrationTest
}

# Function to run integration tests
run_integration_tests() {
    print_header "Running Integration Tests with Testcontainers"
    check_docker
    mvn failsafe:integration-test failsafe:verify -Dgroups=IntegrationTest
}

# Function to run a specific test
run_specific_test() {
    print_header "Running Specific Test: $1"
    check_docker
    mvn test -Dtest=$1
}

# Function to run all tests
run_all_tests() {
    print_header "Running All Tests (Unit Tests + Integration Tests)"
    check_docker
    mvn verify
}

# Function to display help
show_help() {
    echo -e "${GREEN}Waqiti Notification Service Test Runner${NC}"
    echo -e "${YELLOW}Usage:${NC}"
    echo -e "  $0 [option]"
    echo -e "\n${YELLOW}Options:${NC}"
    echo -e "  ${GREEN}unit${NC}         Run unit tests only"
    echo -e "  ${GREEN}integration${NC}  Run integration tests with Testcontainers"
    echo -e "  ${GREEN}all${NC}          Run all tests (unit + integration)"
    echo -e "  ${GREEN}specific${NC}     Run a specific test class (requires test class name)"
    echo -e "  ${GREEN}help${NC}         Show this help message"
    echo -e "\n${YELLOW}Example:${NC}"
    echo -e "  $0 unit                                # Run unit tests"
    echo -e "  $0 integration                         # Run integration tests"
    echo -e "  $0 specific NotificationRepositoryTest # Run specific test class"
}

# Main script logic
case "$1" in
    "unit")
        run_unit_tests
        ;;
    "integration")
        run_integration_tests
        ;;
    "all")
        run_all_tests
        ;;
    "specific")
        if [ -z "$2" ]; then
            echo -e "${RED}Error: Please provide a test class name.${NC}"
            echo -e "Example: $0 specific NotificationRepositoryTest"
            exit 1
        fi
        run_specific_test "$2"
        ;;
    "help" | *)
        show_help
        ;;
esac

# Exit with the status of the last command
exit $?
```

### notification-service/Dockerfile

```
FROM eclipse-temurin:17-jdk-alpine as build
WORKDIR /workspace/app

# Copy maven executables and configuration
COPY mvnw .
COPY .mvn .mvn
COPY pom.xml .
COPY notification-service/pom.xml ./notification-service/
COPY common/pom.xml ./common/

# Make the maven wrapper executable
RUN chmod +x ./mvnw

# Download dependencies
RUN ./mvnw dependency:go-offline -B

# Copy source code
COPY common/src ./common/src
COPY notification-service/src ./notification-service/src

# Build the application
RUN ./mvnw clean package -pl notification-service -am -DskipTests

FROM eclipse-temurin:17-jre-alpine
VOLUME /tmp

# Add application user
RUN addgroup -S appgroup && adduser -S appuser -G appgroup
USER appuser

# Copy the built JAR from the build stage
COPY --from=build /workspace/app/notification-service/target/*.jar app.jar

# Set health check
HEALTHCHECK --interval=30s --timeout=10s --retries=3 CMD wget -q --spider http://localhost:8084/actuator/health || exit 1

# Run the application
ENTRYPOINT ["java", "-jar", "/app.jar"]
```

### notification-service/pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.waqiti</groupId>
        <artifactId>waqiti-app</artifactId>
        <version>1.0-SNAPSHOT</version>
        <relativePath>../../pom.xml</relativePath>
    </parent>

    <artifactId>notification-service</artifactId>
    <name>Notification Service</name>
    <description>Notification service for waqiti</description>

    <properties>
        <java.version>17</java.version>
        <!-- Update to match parent pom's Spring Cloud version -->
        <spring-cloud.version>2023.0.0</spring-cloud.version>
        <testcontainers.version>1.19.0</testcontainers.version>
        <awaitility.version>4.2.0</awaitility.version>
        <firebase-admin.version>9.2.0</firebase-admin.version>
    </properties>

    <dependencies>
        <!-- Spring Boot -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-cache</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <!-- Spring Cloud -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-config</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>

        <!-- Kafka -->
        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>

        <!-- Firebase Admin SDK - using property reference -->
        <dependency>
            <groupId>com.google.firebase</groupId>
            <artifactId>firebase-admin</artifactId>
            <version>${firebase-admin.version}</version>
        </dependency>

        <!-- Common module -->
        <dependency>
            <groupId>com.waqiti</groupId>
            <artifactId>common</artifactId>
            <version>${project.version}</version>
        </dependency>

        <!-- Add to services/notification-service/pom.xml in the dependencies section -->
        <dependency>
            <groupId>com.twilio.sdk</groupId>
            <artifactId>twilio</artifactId>
            <version>9.7.0</version>
        </dependency>

        <!-- Utilities -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>io.github.resilience4j</groupId>
            <artifactId>resilience4j-spring-boot2</artifactId>
        </dependency>
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-registry-prometheus</artifactId>
        </dependency>

        <!-- Test dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Jakarta Mail API - needed for javax.mail.internet (Java EE -> Jakarta EE transition) -->
        <dependency>
            <groupId>jakarta.mail</groupId>
            <artifactId>jakarta.mail-api</artifactId>
            <version>2.1.2</version>
        </dependency>

        <!-- Testcontainers dependencies -->
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <version>5.3.1</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>kafka</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>

        <!-- Awaitility for async testing -->
        <dependency>
            <groupId>org.awaitility</groupId>
            <artifactId>awaitility</artifactId>
            <version>${awaitility.version}</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>

            <!-- Maven Surefire Plugin for running tests -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <configuration>
                    <!-- Run tests in parallel for faster execution -->
                    <parallel>methods</parallel>
                    <threadCount>4</threadCount>
                    <perCoreThreadCount>true</perCoreThreadCount>

                    <!-- Timeout for tests -->
                    <forkedProcessTimeoutInSeconds>600</forkedProcessTimeoutInSeconds>

                    <!-- System properties passed to tests -->
                    <systemPropertyVariables>
                        <!-- Enable Testcontainers reuse to speed up tests -->
                        <testcontainers.reuse.enable>true</testcontainers.reuse.enable>
                        <!-- Spring profile for tests -->
                        <spring.profiles.active>test</spring.profiles.active>
                    </systemPropertyVariables>

                    <!-- Exclude integration tests from regular test run -->
                    <excludedGroups>IntegrationTest</excludedGroups>
                </configuration>
            </plugin>

            <!-- Maven Failsafe Plugin for integration tests -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-failsafe-plugin</artifactId>
                <configuration>
                    <!-- Only run integration tests -->
                    <groups>IntegrationTest</groups>

                    <!-- System properties passed to tests -->
                    <systemPropertyVariables>
                        <!-- Enable Testcontainers reuse to speed up tests -->
                        <testcontainers.reuse.enable>true</testcontainers.reuse.enable>
                        <!-- Spring profile for tests -->
                        <spring.profiles.active>test</spring.profiles.active>
                    </systemPropertyVariables>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>integration-test</goal>
                            <goal>verify</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```

### notification-service/src/main/resources/application.yml

```yml
server:
  port: 8084

spring:
  application:
    name: notification-service

  # Database configuration
  datasource:
    url: jdbc:postgresql://localhost:5432/waqiti
    username: app_user
    password: ${DB_PASSWORD:strongpassword}

  jpa:
    hibernate:
      ddl-auto: none
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
    show-sql: false

  # Database migrations
  flyway:
    enabled: true
    locations: classpath:db/migration
    baseline-on-migrate: true

  # Kafka configuration
  kafka:
    bootstrap-servers: localhost:9092
    consumer:
      group-id: notification-service
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: com.waqiti.notification.event
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

  # Redis cache
  data:
    redis:
      host: localhost
      port: 6379

  # Email configuration
  mail:
    host: ${MAIL_HOST:localhost}
    port: ${MAIL_PORT:1025}
    username: ${MAIL_USERNAME:}
    password: ${MAIL_PASSWORD:}
    properties:
      mail.smtp.auth: ${MAIL_SMTP_AUTH:false}
      mail.smtp.starttls.enable: ${MAIL_SMTP_STARTTLS:false}

  # Thymeleaf configuration
  thymeleaf:
    enabled: true
    cache: false
    check-template: true
    check-template-location: true
    prefix: classpath:/templates/
    suffix: .html
    encoding: UTF-8

# External services
user-service:
  url: http://localhost:8081

# Firebase configuration
firebase:
  config-file: ${FIREBASE_CONFIG_FILE:firebase-service-account.json}

# Security
security:
  jwt:
    token:
      secret-key: ${JWT_SECRET:c3VwZXJzZWNyZXRrZXljYW50YnVzdA==} # Base64 encoded value

# Notification settings
notification:
  email:
    from: no-reply@waqiti.com
    personal: waqiti
  sms:
    from: ${SMS_FROM:+270785046229}

# Resilience4j configuration
resilience4j:
  circuitbreaker:
    instances:
      userService:
        registerHealthIndicator: true
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        permittedNumberOfCallsInHalfOpenState: 3
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 5s
        failureRateThreshold: 50
        eventConsumerBufferSize: 10
  retry:
    instances:
      userService:
        maxAttempts: 3
        waitDuration: 1s
        enableExponentialBackoff: true
        exponentialBackoffMultiplier: 2

# Cache configuration
cache:
  templates:
    ttl: 3600 # Cache templates for 1 hour

# Logging
logging:
  level:
    root: INFO
    com.waqiti: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  pattern:
    console: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: logs/${spring.application.name}.log

# Management endpoints
management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus,metrics
  metrics:
    export:
      prometheus:
        enabled: true
  health:
    circuitbreakers:
      enabled: true

# Add to services/notification-service/src/main/resources/application.yml

# Twilio Configuration
twilio:
  enabled: ${TWILIO_ENABLED:false}
  account:
    sid: ${TWILIO_ACCOUNT_SID:}
    token: ${TWILIO_AUTH_TOKEN:}
```

### notification-service/src/main/resources/db/migration/V2__add_2fa_templates.sql

```sql
-- File: services/notification-service/src/main/resources/db/migration/V2__add_2fa_templates.sql

-- Create template for 2FA SMS notifications
INSERT INTO notification_templates (
    id, code, name, category, title_template, message_template,
    email_subject_template, email_body_template, sms_template,
    action_url_template, enabled, created_at, updated_at
) VALUES (
             gen_random_uuid(), 'two_factor_code', '2FA Verification Code', 'SECURITY',
             'Verification Code', 'Your verification code is: ${code}',
             'Security Verification Code',
             '<div style="font-family: Arial, sans-serif; padding: 20px; max-width: 600px; margin: 0 auto; border: 1px solid #e0e0e0; border-radius: 5px;">
                 <h2 style="color: #333;">Security Verification</h2>
                 <p>Your verification code is: <strong>${code}</strong></p>
                 <p>This code will expire in 10 minutes.</p>
                 <p>If you did not request this code, please ignore this message.</p>
                 <p style="margin-top: 30px; font-size: 12px; color: #777;">
                     This is an automated message, please do not reply.
                 </p>
             </div>',
             'Your Waqiti verification code is: ${code}',
             NULL, true, NOW(), NOW()
         );

-- Create template for 2FA email notifications
INSERT INTO notification_templates (
    id, code, name, category, title_template, message_template,
    email_subject_template, email_body_template, sms_template,
    action_url_template, enabled, created_at, updated_at
) VALUES (
             gen_random_uuid(), 'two_factor_email', '2FA Email Verification Code', 'SECURITY',
             'Verification Code', 'Your verification code is: ${code}',
             'Security Verification Code',
             '<div style="font-family: Arial, sans-serif; padding: 20px; max-width: 600px; margin: 0 auto; border: 1px solid #e0e0e0; border-radius: 5px;">
                 <h2 style="color: #333;">Security Verification</h2>
                 <p>Your verification code for ${email} is: <strong>${code}</strong></p>
                 <p>This code will expire in 10 minutes.</p>
                 <p>If you did not request this code, please ignore this message.</p>
                 <p style="margin-top: 30px; font-size: 12px; color: #777;">
                     This is an automated message, please do not reply.
                 </p>
             </div>',
             NULL,
             NULL, true, NOW(), NOW()
         );
```

### notification-service/src/main/resources/db/migration/V1__create_notification_tables.sql

```sql
-- Create Notifications Table
CREATE TABLE notifications (
                               id UUID PRIMARY KEY,
                               user_id UUID NOT NULL,
                               title VARCHAR(100) NOT NULL,
                               message VARCHAR(1000) NOT NULL,
                               type VARCHAR(20) NOT NULL,
                               category VARCHAR(100),
                               reference_id VARCHAR(100),
                               read BOOLEAN NOT NULL DEFAULT FALSE,
                               action_url VARCHAR(500),
                               created_at TIMESTAMP NOT NULL,
                               expires_at TIMESTAMP,
                               read_at TIMESTAMP,
                               delivery_status VARCHAR(20) NOT NULL,
                               delivery_error VARCHAR(500),
                               version BIGINT NOT NULL DEFAULT 0,
                               created_by VARCHAR(100)
);

-- Create Notification Preferences Table
CREATE TABLE notification_preferences (
                                          user_id UUID PRIMARY KEY,
                                          app_notifications_enabled BOOLEAN NOT NULL DEFAULT TRUE,
                                          email_notifications_enabled BOOLEAN NOT NULL DEFAULT TRUE,
                                          sms_notifications_enabled BOOLEAN NOT NULL DEFAULT FALSE,
                                          push_notifications_enabled BOOLEAN NOT NULL DEFAULT FALSE,
                                          quiet_hours_start INTEGER,
                                          quiet_hours_end INTEGER,
                                          email VARCHAR(255),
                                          phone_number VARCHAR(20),
                                          device_token VARCHAR(500),
                                          created_at TIMESTAMP NOT NULL,
                                          updated_at TIMESTAMP NOT NULL,
                                          version BIGINT NOT NULL DEFAULT 0,
                                          created_by VARCHAR(100),
                                          updated_by VARCHAR(100)
);

-- Create Category Preferences Table
CREATE TABLE category_preferences (
                                      user_id UUID NOT NULL REFERENCES notification_preferences(user_id),
                                      category VARCHAR(50) NOT NULL,
                                      enabled BOOLEAN NOT NULL DEFAULT TRUE,
                                      PRIMARY KEY (user_id, category)
);

-- Create Notification Templates Table
CREATE TABLE notification_templates (
                                        id UUID PRIMARY KEY,
                                        code VARCHAR(100) NOT NULL UNIQUE,
                                        name VARCHAR(100) NOT NULL,
                                        category VARCHAR(100) NOT NULL,
                                        title_template VARCHAR(200) NOT NULL,
                                        message_template VARCHAR(2000) NOT NULL,
                                        email_subject_template VARCHAR(2000),
                                        email_body_template VARCHAR(5000),
                                        sms_template VARCHAR(200),
                                        action_url_template VARCHAR(500),
                                        enabled BOOLEAN NOT NULL DEFAULT TRUE,
                                        created_at TIMESTAMP NOT NULL,
                                        updated_at TIMESTAMP NOT NULL,
                                        created_by VARCHAR(100),
                                        updated_by VARCHAR(100)
);

-- Create indexes
CREATE INDEX idx_notifications_user_id ON notifications(user_id);
CREATE INDEX idx_notifications_created_at ON notifications(created_at);
CREATE INDEX idx_notifications_read ON notifications(read);
CREATE INDEX idx_notifications_delivery_status ON notifications(delivery_status);
CREATE INDEX idx_notifications_category ON notifications(category);
CREATE INDEX idx_notifications_reference_id ON notifications(reference_id);
CREATE INDEX idx_notification_templates_code ON notification_templates(code);
CREATE INDEX idx_notification_templates_category ON notification_templates(category);
```

### notification-service/src/main/java/com/waqiti/notification/NotificationServiceApplication.java

**Dependencies:**
- External: `org.springframework.boot.SpringApplication`, `org.springframework.boot.autoconfigure.SpringBootApplication`, `org.springframework.cache.annotation.EnableCaching` and 3 more

```java
package com.waqiti.notification;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableJpaRepositories
@EnableFeignClients
@EnableCaching
@EnableScheduling
public class NotificationServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(NotificationServiceApplication.class, args);
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/dto/UpdatePreferencesRequest.java

**Dependencies:**
- External: `com.fasterxml.jackson.annotation.JsonInclude`, `jakarta.validation.constraints.NotBlank`, `jakarta.validation.constraints.NotNull` and 9 more

```java
package com.waqiti.notification.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * Request to update notification preferences
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UpdatePreferencesRequest {
    private Boolean appNotificationsEnabled;
    private Boolean emailNotificationsEnabled;
    private Boolean smsNotificationsEnabled;
    private Boolean pushNotificationsEnabled;
    private Map<String, Boolean> categoryPreferences;
    private Integer quietHoursStart;
    private Integer quietHoursEnd;
    private String email;
    private String phoneNumber;
    private String deviceToken;
}

```

### notification-service/src/main/java/com/waqiti/notification/dto/NotificationTemplateResponse.java

**Dependencies:**
- External: `com.fasterxml.jackson.annotation.JsonInclude`, `java.time.LocalDateTime`, `java.util.UUID` and 4 more

```java
package com.waqiti.notification.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID; /**
 * Response for notification template operations
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NotificationTemplateResponse {
    private UUID id;
    private String code;
    private String name;
    private String category;
    private String titleTemplate;
    private String messageTemplate;
    private String emailSubjectTemplate;
    private String emailBodyTemplate;
    private String smsTemplate;
    private String actionUrlTemplate;
    private boolean enabled;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```

### notification-service/src/main/java/com/waqiti/notification/dto/TwoFactorNotificationRequest.java

**Dependencies:**
- External: `jakarta.validation.constraints.NotBlank`, `jakarta.validation.constraints.NotNull`, `java.util.UUID` and 4 more

```java
// File: services/notification-service/src/main/java/com/waqiti/notification/dto/TwoFactorNotificationRequest.java
package com.waqiti.notification.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.UUID;

/**
 * Request to send a 2FA notification
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TwoFactorNotificationRequest {
    @NotNull(message = "User ID is required")
    private UUID userId;

    @NotBlank(message = "Recipient is required")
    private String recipient;

    @NotBlank(message = "Verification code is required")
    private String verificationCode;

    private String language = "en";
}
```

### notification-service/src/main/java/com/waqiti/notification/dto/NotificationResponse.java

**Dependencies:**
- External: `com.fasterxml.jackson.annotation.JsonInclude`, `java.time.LocalDateTime`, `java.util.UUID` and 4 more

```java
package com.waqiti.notification.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID; /**
 * Response for notification operations
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NotificationResponse {
    private UUID id;
    private UUID userId;
    private String title;
    private String message;
    private String type;
    private String category;
    private String referenceId;
    private boolean read;
    private String actionUrl;
    private LocalDateTime createdAt;
    private LocalDateTime expiresAt;
    private LocalDateTime readAt;
    private String deliveryStatus;
}
```

### notification-service/src/main/java/com/waqiti/notification/dto/NotificationTemplateRequest.java

**Dependencies:**
- External: `jakarta.validation.constraints.NotBlank`, `jakarta.validation.constraints.Size`, `lombok.AllArgsConstructor` and 3 more

```java
package com.waqiti.notification.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor; /**
 * Request to create or update a notification template
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NotificationTemplateRequest {
    @NotBlank(message = "Code is required")
    @Size(max = 100, message = "Code cannot exceed 100 characters")
    private String code;

    @NotBlank(message = "Name is required")
    @Size(max = 100, message = "Name cannot exceed 100 characters")
    private String name;

    @NotBlank(message = "Category is required")
    @Size(max = 100, message = "Category cannot exceed 100 characters")
    private String category;

    @NotBlank(message = "Title template is required")
    @Size(max = 200, message = "Title template cannot exceed 200 characters")
    private String titleTemplate;

    @NotBlank(message = "Message template is required")
    @Size(max = 2000, message = "Message template cannot exceed 2000 characters")
    private String messageTemplate;

    @Size(max = 2000, message = "Email subject template cannot exceed 2000 characters")
    private String emailSubjectTemplate;

    @Size(max = 5000, message = "Email body template cannot exceed 5000 characters")
    private String emailBodyTemplate;

    @Size(max = 200, message = "SMS template cannot exceed 200 characters")
    private String smsTemplate;

    @Size(max = 500, message = "Action URL template cannot exceed 500 characters")
    private String actionUrlTemplate;

    private boolean enabled;
}
```

### notification-service/src/main/java/com/waqiti/notification/dto/SendNotificationRequest.java

**Dependencies:**
- External: `jakarta.validation.constraints.NotBlank`, `jakarta.validation.constraints.NotNull`, `java.time.LocalDateTime` and 6 more

```java
package com.waqiti.notification.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID; /**
 * Request to send a notification
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SendNotificationRequest {
    @NotNull(message = "User ID is required")
    private UUID userId;

    @NotBlank(message = "Template code is required")
    private String templateCode;

    // Parameters for the template
    private Map<String, Object> parameters;

    // Types of notification to send (if not specified, sends based on user preferences)
    private String[] types;

    // Optional reference ID for tracking
    private String referenceId;

    // Optional action URL
    private String actionUrl;

    // Optional expiry date
    private LocalDateTime expiresAt;
}
```

### notification-service/src/main/java/com/waqiti/notification/dto/NotificationPreferencesResponse.java

**Dependencies:**
- External: `com.fasterxml.jackson.annotation.JsonInclude`, `java.time.LocalDateTime`, `java.util.Map` and 5 more

```java
package com.waqiti.notification.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID; /**
 * Response for notification preferences
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NotificationPreferencesResponse {
    private UUID userId;
    private boolean appNotificationsEnabled;
    private boolean emailNotificationsEnabled;
    private boolean smsNotificationsEnabled;
    private boolean pushNotificationsEnabled;
    private Map<String, Boolean> categoryPreferences;
    private Integer quietHoursStart;
    private Integer quietHoursEnd;
    private String email;
    private String phoneNumber;
    private boolean deviceTokenRegistered;
    private LocalDateTime updatedAt;
}
```

### notification-service/src/main/java/com/waqiti/notification/dto/NotificationListResponse.java

**Dependencies:**
- External: `com.fasterxml.jackson.annotation.JsonInclude`, `java.util.List`, `lombok.AllArgsConstructor` and 3 more

```java
package com.waqiti.notification.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List; /**
 * Response for notification list operations
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NotificationListResponse {
    private List<NotificationResponse> notifications;
    private long unreadCount;
    private int totalPages;
    private long totalElements;
    private int page;
    private int size;
}
```

### notification-service/src/main/java/com/waqiti/notification/repository/NotificationRepository.java

**Dependencies:**
- Internal: `notification-service/src/main/java/com/waqiti/notification/domain/DeliveryStatus.java`, `notification-service/src/main/java/com/waqiti/notification/domain/Notification.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationType.java`
- External: `java.time.LocalDateTime`, `java.util.List`, `java.util.UUID` and 6 more

```java
package com.waqiti.notification.repository;

import com.waqiti.notification.domain.DeliveryStatus;
import com.waqiti.notification.domain.Notification;
import com.waqiti.notification.domain.NotificationType;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Repository
public interface NotificationRepository extends JpaRepository<Notification, UUID> {
    /**
     * Find notifications by user ID, sorted by creation date
     */
    Page<Notification> findByUserIdOrderByCreatedAtDesc(UUID userId, Pageable pageable);

    /**
     * Find unread notifications by user ID
     */
    Page<Notification> findByUserIdAndReadFalseOrderByCreatedAtDesc(UUID userId, Pageable pageable);

    /**
     * Find notifications by user ID and category
     */
    Page<Notification> findByUserIdAndCategoryOrderByCreatedAtDesc(UUID userId, String category, Pageable pageable);

    /**
     * Find notifications by delivery status
     */
    List<Notification> findByDeliveryStatus(DeliveryStatus status);

    /**
     * Find notifications by type and delivery status
     */
    List<Notification> findByTypeAndDeliveryStatus(NotificationType type, DeliveryStatus status);

    /**
     * Count unread notifications by user ID
     */
    long countByUserIdAndReadFalse(UUID userId);

    /**
     * Find expired unread notifications to clean up
     */
    List<Notification> findByReadFalseAndExpiresAtBeforeAndDeliveryStatus(
            LocalDateTime now, DeliveryStatus status);

    /**
     * Find notifications by reference ID
     */
    List<Notification> findByReferenceId(String referenceId);

    /**
     * Find latest notification by user ID and category
     */
    @Query("SELECT n FROM Notification n WHERE n.userId = :userId AND n.category = :category " +
            "ORDER BY n.createdAt DESC LIMIT 1")
    Notification findLatestByUserIdAndCategory(@Param("userId") UUID userId, @Param("category") String category);
}
```

### notification-service/src/main/java/com/waqiti/notification/repository/NotificationTemplateRepository.java

**Dependencies:**
- Internal: `notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java`
- External: `java.util.List`, `java.util.Optional`, `java.util.UUID` and 2 more

```java
package com.waqiti.notification.repository;

import com.waqiti.notification.domain.NotificationTemplate;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface NotificationTemplateRepository extends JpaRepository<NotificationTemplate, UUID> {
    /**
     * Find template by code
     */
    Optional<NotificationTemplate> findByCode(String code);

    /**
     * Find templates by category
     */
    List<NotificationTemplate> findByCategory(String category);

    /**
     * Find enabled templates
     */
    List<NotificationTemplate> findByEnabledTrue();

    /**
     * Find enabled templates by category
     */
    List<NotificationTemplate> findByCategoryAndEnabledTrue(String category);

    /**
     * Check if a template exists by code
     */
    boolean existsByCode(String code);
}
```

### notification-service/src/main/java/com/waqiti/notification/repository/NotificationPreferencesRepository.java

**Dependencies:**
- Internal: `notification-service/src/main/java/com/waqiti/notification/domain/NotificationPreferences.java`
- External: `java.util.List`, `java.util.UUID`, `org.springframework.data.jpa.repository.JpaRepository` and 3 more

```java
package com.waqiti.notification.repository;

import com.waqiti.notification.domain.NotificationPreferences;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.UUID;

@Repository
public interface NotificationPreferencesRepository extends JpaRepository<NotificationPreferences, UUID> {
    /**
     * Find users who have enabled a specific notification type
     */
    @Query("SELECT np.userId FROM NotificationPreferences np WHERE " +
           "(:type = 'APP' AND np.appNotificationsEnabled = true) OR " +
           "(:type = 'EMAIL' AND np.emailNotificationsEnabled = true) OR " +
           "(:type = 'SMS' AND np.smsNotificationsEnabled = true) OR " +
           "(:type = 'PUSH' AND np.pushNotificationsEnabled = true)")
    List<UUID> findUserIdsWithEnabledNotificationType(@Param("type") String type);

    /**
     * Find users who have enabled a specific category
     */
    @Query("SELECT np.userId FROM NotificationPreferences np JOIN np.categoryPreferences cp " +
           "WHERE KEY(cp) = :category AND VALUE(cp) = true")
    List<UUID> findUserIdsWithEnabledCategory(@Param("category") String category);

    /**
     * Find users with device tokens for push notifications
     */
    @Query("SELECT np FROM NotificationPreferences np WHERE " +
           "np.pushNotificationsEnabled = true AND np.deviceToken IS NOT NULL")
    List<NotificationPreferences> findUsersForPushNotifications();
}
```

### notification-service/src/main/java/com/waqiti/notification/config/FirebaseConfig.java

**Dependencies:**
- External: `com.google.auth.oauth2.GoogleCredentials`, `com.google.firebase.FirebaseApp`, `com.google.firebase.FirebaseOptions` and 9 more

```java
/**
 * File: src/main/java/com/waqiti/notification/config/FirebaseConfig.java
 */
package com.waqiti.notification.config;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;
import com.google.firebase.messaging.FirebaseMessaging;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.core.io.ClassPathResource;

import java.io.IOException;
import java.io.InputStream;

@Configuration
@Slf4j
public class FirebaseConfig {

    @Value("${firebase.config-file:firebase-service-account.json}")
    private String firebaseConfigFile;

    @Value("${firebase.enabled:true}")
    private boolean firebaseEnabled;

    @Bean
    @Profile("!test") // Use real implementation in non-test environments
    public FirebaseMessaging firebaseMessaging() {
        if (!firebaseEnabled) {
            log.info("Firebase is disabled by configuration");
            return null;
        }

        try {
            InputStream serviceAccount = new ClassPathResource(firebaseConfigFile).getInputStream();
            FirebaseOptions options = FirebaseOptions.builder()
                    .setCredentials(GoogleCredentials.fromStream(serviceAccount))
                    .build();

            if (FirebaseApp.getApps().isEmpty()) {
                FirebaseApp app = FirebaseApp.initializeApp(options);
                log.info("Firebase application has been initialized");
                return FirebaseMessaging.getInstance(app);
            }

            return FirebaseMessaging.getInstance();
        } catch (Exception e) {
            log.error("Failed to initialize Firebase", e);
            // Return null which our NotificationSenderService can handle gracefully
            return null;
        }
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/config/KafkaConsumerConfig.java

**Dependencies:**
- External: `java.util.HashMap`, `java.util.Map`, `lombok.extern.slf4j.Slf4j` and 12 more

```java
package com.waqiti.notification.config;

import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.annotation.EnableKafka;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.listener.ContainerProperties;
import org.springframework.kafka.listener.DefaultErrorHandler;
import org.springframework.util.backoff.FixedBackOff;

import java.util.HashMap;
import java.util.Map;

@Configuration
@EnableKafka
@Slf4j
public class KafkaConsumerConfig {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    @Value("${spring.kafka.consumer.group-id}")
    private String groupId;

    @Bean
    public ConsumerFactory<String, String> consumerFactory() {
        Map<String, Object> props = new HashMap<>();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);

        return new DefaultKafkaConsumerFactory<>(props);
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, String> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, String> factory =
                new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL_IMMEDIATE);

        // Configure error handler with retry
        DefaultErrorHandler errorHandler = new DefaultErrorHandler(
                (record, exception) -> {
                    log.error("Failed to process message: {}", record.value(), exception);
                },
                new FixedBackOff(1000L, 3) // Retry 3 times with 1s delay
        );

        factory.setCommonErrorHandler(errorHandler);

        return factory;
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/api/NotificationTemplateController.java

**Dependencies:**
- Internal: `notification-service/src/main/java/com/waqiti/notification/dto/NotificationTemplateRequest.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationTemplateResponse.java`, `notification-service/src/main/java/com/waqiti/notification/service/NotificationTemplateService.java`
- External: `jakarta.validation.Valid`, `java.util.List`, `java.util.UUID` and 5 more

```java
package com.waqiti.notification.api;

import com.waqiti.notification.dto.NotificationTemplateRequest;
import com.waqiti.notification.dto.NotificationTemplateResponse;
import com.waqiti.notification.service.NotificationTemplateService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/notifications/templates")
@RequiredArgsConstructor
@Slf4j
public class NotificationTemplateController {
    private final NotificationTemplateService templateService;

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<NotificationTemplateResponse> createTemplate(
            @Valid @RequestBody NotificationTemplateRequest request) {
        log.info("Create notification template request received");
        return ResponseEntity.ok(templateService.createTemplate(request));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<NotificationTemplateResponse> updateTemplate(
            @PathVariable UUID id,
            @Valid @RequestBody NotificationTemplateRequest request) {
        log.info("Update notification template request received for ID: {}", id);
        return ResponseEntity.ok(templateService.updateTemplate(id, request));
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<NotificationTemplateResponse> getTemplate(@PathVariable UUID id) {
        log.info("Get notification template request received for ID: {}", id);
        return ResponseEntity.ok(templateService.getTemplateById(id));
    }

    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<NotificationTemplateResponse>> getAllTemplates() {
        log.info("Get all notification templates request received");
        return ResponseEntity.ok(templateService.getAllTemplates());
    }

    @GetMapping("/category/{category}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<NotificationTemplateResponse>> getTemplatesByCategory(
            @PathVariable String category) {
        log.info("Get notification templates request received for category: {}", category);
        return ResponseEntity.ok(templateService.getTemplatesByCategory(category));
    }

    @PostMapping("/{id}/enable")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<NotificationTemplateResponse> enableTemplate(@PathVariable UUID id) {
        log.info("Enable notification template request received for ID: {}", id);
        return ResponseEntity.ok(templateService.setTemplateEnabled(id, true));
    }

    @PostMapping("/{id}/disable")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<NotificationTemplateResponse> disableTemplate(@PathVariable UUID id) {
        log.info("Disable notification template request received for ID: {}", id);
        return ResponseEntity.ok(templateService.setTemplateEnabled(id, false));
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/api/NotificationController.java

**Dependencies:**
- Internal: `notification-service/src/main/java/com/waqiti/notification/dto/NotificationListResponse.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationResponse.java`, `notification-service/src/main/java/com/waqiti/notification/dto/SendNotificationRequest.java` and 1 more
- External: `jakarta.validation.Valid`, `java.util.List`, `java.util.UUID` and 10 more

```java
package com.waqiti.notification.api;

import com.waqiti.notification.dto.NotificationListResponse;
import com.waqiti.notification.dto.NotificationResponse;
import com.waqiti.notification.dto.SendNotificationRequest;
import com.waqiti.notification.service.NotificationService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/notifications")
@RequiredArgsConstructor
@Slf4j
public class NotificationController {
    private final NotificationService notificationService;

    @PostMapping("/send")
    public ResponseEntity<List<NotificationResponse>> sendNotification(
            @Valid @RequestBody SendNotificationRequest request) {
        log.info("Send notification request received");
        return ResponseEntity.ok(notificationService.sendNotification(request));
    }

    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<NotificationListResponse> getNotifications(
            @AuthenticationPrincipal UserDetails userDetails,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        log.info("Get notifications request received");

        UUID userId = getUserIdFromUserDetails(userDetails);
        Pageable pageable = PageRequest.of(page, size, Sort.by("createdAt").descending());

        return ResponseEntity.ok(notificationService.getNotifications(userId, pageable));
    }

    @GetMapping("/unread")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<NotificationListResponse> getUnreadNotifications(
            @AuthenticationPrincipal UserDetails userDetails,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        log.info("Get unread notifications request received");

        UUID userId = getUserIdFromUserDetails(userDetails);
        Pageable pageable = PageRequest.of(page, size, Sort.by("createdAt").descending());

        return ResponseEntity.ok(notificationService.getUnreadNotifications(userId, pageable));
    }

    @GetMapping("/{id}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<NotificationResponse> getNotification(@PathVariable UUID id) {
        log.info("Get notification request received for ID: {}", id);
        return ResponseEntity.ok(notificationService.getNotification(id));
    }

    @PostMapping("/{id}/read")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<NotificationResponse> markAsRead(@PathVariable UUID id) {
        log.info("Mark notification as read request received for ID: {}", id);
        return ResponseEntity.ok(notificationService.markAsRead(id));
    }

    @PostMapping("/read-all")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Void> markAllAsRead(@AuthenticationPrincipal UserDetails userDetails) {
        log.info("Mark all notifications as read request received");

        UUID userId = getUserIdFromUserDetails(userDetails);
        notificationService.markAllAsRead(userId);

        return ResponseEntity.ok().build();
    }

    /**
     * Helper method to extract user ID from UserDetails
     */
    private UUID getUserIdFromUserDetails(UserDetails userDetails) {
        return UUID.fromString(userDetails.getUsername());
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/api/TwoFactorNotificationController.java

**Dependencies:**
- Internal: `notification-service/src/main/java/com/waqiti/notification/dto/TwoFactorNotificationRequest.java`, `notification-service/src/main/java/com/waqiti/notification/service/TwoFactorNotificationService.java`
- External: `jakarta.validation.Valid`, `java.util.UUID`, `lombok.RequiredArgsConstructor` and 4 more

```java
// File: services/notification-service/src/main/java/com/waqiti/notification/api/TwoFactorNotificationController.java
package com.waqiti.notification.api;

import com.waqiti.notification.dto.TwoFactorNotificationRequest;
import com.waqiti.notification.service.TwoFactorNotificationService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/api/v1/notifications/2fa")
@RequiredArgsConstructor
@Slf4j
public class TwoFactorNotificationController {

    private final TwoFactorNotificationService twoFactorService;

    /**
     * Sends a 2FA verification code via SMS
     */
    @PostMapping("/sms")
    @PreAuthorize("hasRole('SERVICE')")
    public ResponseEntity<Boolean> sendTwoFactorSms(
            @Valid @RequestBody TwoFactorNotificationRequest request) {

        log.info("Received request to send 2FA SMS to user: {}", request.getUserId());

        boolean success = twoFactorService.sendTwoFactorSms(
                request.getUserId(),
                request.getRecipient(),
                request.getVerificationCode()
        );

        return ResponseEntity.ok(success);
    }

    /**
     * Sends a 2FA verification code via email
     */
    @PostMapping("/email")
    @PreAuthorize("hasRole('SERVICE')")
    public ResponseEntity<Boolean> sendTwoFactorEmail(
            @Valid @RequestBody TwoFactorNotificationRequest request) {

        log.info("Received request to send 2FA email to user: {}", request.getUserId());

        boolean success = twoFactorService.sendTwoFactorEmail(
                request.getUserId(),
                request.getRecipient(),
                request.getVerificationCode()
        );

        return ResponseEntity.ok(success);
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/api/NotificationPreferencesController.java

**Dependencies:**
- Internal: `notification-service/src/main/java/com/waqiti/notification/dto/NotificationPreferencesResponse.java`, `notification-service/src/main/java/com/waqiti/notification/dto/UpdatePreferencesRequest.java`, `notification-service/src/main/java/com/waqiti/notification/service/NotificationPreferencesService.java`
- External: `jakarta.validation.Valid`, `java.util.UUID`, `lombok.RequiredArgsConstructor` and 6 more

```java
package com.waqiti.notification.api;

import com.waqiti.notification.dto.NotificationPreferencesResponse;
import com.waqiti.notification.dto.UpdatePreferencesRequest;
import com.waqiti.notification.service.NotificationPreferencesService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/api/v1/notifications/preferences")
@RequiredArgsConstructor
@Slf4j
public class NotificationPreferencesController {
    private final NotificationPreferencesService preferencesService;

    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<NotificationPreferencesResponse> getPreferences(
            @AuthenticationPrincipal UserDetails userDetails) {
        log.info("Get notification preferences request received");

        UUID userId = getUserIdFromUserDetails(userDetails);
        return ResponseEntity.ok(preferencesService.getPreferences(userId));
    }

    @PutMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<NotificationPreferencesResponse> updatePreferences(
            @AuthenticationPrincipal UserDetails userDetails,
            @Valid @RequestBody UpdatePreferencesRequest request) {
        log.info("Update notification preferences request received");

        UUID userId = getUserIdFromUserDetails(userDetails);
        return ResponseEntity.ok(preferencesService.updatePreferences(userId, request));
    }

    @PostMapping("/device-token")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Void> updateDeviceToken(
            @AuthenticationPrincipal UserDetails userDetails,
            @RequestBody String deviceToken) {
        log.info("Update device token request received");

        UUID userId = getUserIdFromUserDetails(userDetails);
        preferencesService.updateDeviceToken(userId, deviceToken);

        return ResponseEntity.ok().build();
    }

    /**
     * Helper method to extract user ID from UserDetails
     */
    private UUID getUserIdFromUserDetails(UserDetails userDetails) {
        return UUID.fromString(userDetails.getUsername());
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/service/NotificationSenderService.java

**Dependencies:**
- Internal: `notification-service/src/main/java/com/waqiti/notification/domain/Notification.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationPreferences.java`, `notification-service/src/main/java/com/waqiti/notification/repository/NotificationPreferencesRepository.java` and 1 more
- External: `com.google.firebase.messaging.FirebaseMessaging`, `com.google.firebase.messaging.FirebaseMessagingException`, `com.google.firebase.messaging.Message` and 9 more

```java
/**
 * File: src/main/java/com/waqiti/notification/service/NotificationSenderService.java
 */
package com.waqiti.notification.service;

import com.google.firebase.messaging.FirebaseMessaging;
import com.google.firebase.messaging.Message;
import com.google.firebase.messaging.FirebaseMessagingException;
import com.waqiti.notification.domain.Notification;
import com.waqiti.notification.domain.NotificationPreferences;
import com.waqiti.notification.repository.NotificationPreferencesRepository;
import com.waqiti.notification.service.provider.SmsProvider;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.lang.Nullable;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;

import jakarta.mail.internet.MimeMessage;
import java.util.HashMap;
import java.util.Map;

@Service
@Slf4j
public class NotificationSenderService {
    private final NotificationPreferencesRepository preferencesRepository;
    private final JavaMailSender mailSender;

    // Not final anymore to allow for testing
    private FirebaseMessaging firebaseMessaging;

    @Autowired
    public NotificationSenderService(
            NotificationPreferencesRepository preferencesRepository,
            JavaMailSender mailSender,
            @Nullable FirebaseMessaging firebaseMessaging) {
        this.preferencesRepository = preferencesRepository;
        this.mailSender = mailSender;
        this.firebaseMessaging = firebaseMessaging;
    }

    /**
     * Setter for Firebase messaging - allows for testing with mocks
     * This method is package-private for testing purposes but not meant for general use
     */
    /* package */ void setFirebaseMessaging(FirebaseMessaging firebaseMessaging) {
        this.firebaseMessaging = firebaseMessaging;
    }

    /**
     * Sends an email notification
     */
    public boolean sendEmailNotification(Notification notification, String subject, String body) {
        log.info("Attempting to send email notification for notification ID: {}",
                notification.getId() != null ? notification.getId() : "N/A");

        // Fetch user preferences
        NotificationPreferences preferences = preferencesRepository.findById(notification.getUserId())
                .orElse(null);

        // Validate preferences and email settings
        if (preferences == null || !preferences.isEmailNotificationsEnabled()) {
            log.warn("Email notifications disabled or no preferences found for user: {}",
                    notification.getUserId());
            return false;
        }

        // Validate email address
        if (preferences.getEmail() == null || preferences.getEmail().isEmpty()) {
            log.warn("No email address found for user: {}", notification.getUserId());
            return false;
        }

        try {
            // If subject or body is null, use title/message from notification
            String finalSubject = subject != null ? subject : notification.getTitle();
            String finalBody = body != null ? body : notification.getMessage();

            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");

            helper.setTo(preferences.getEmail());
            helper.setSubject(finalSubject);
            helper.setText(finalBody, true); // true = HTML content

            mailSender.send(message);

            log.info("Email notification sent successfully: {}", notification.getId());
            return true;
        } catch (Exception e) {
            log.error("Error sending email notification: {}. Error: {}",
                    notification.getId(), e.getMessage(), e);
            return false;
        }
    }

    /**
     * Sends an SMS notification
     */
    public boolean sendSmsNotification(Notification notification, String smsText) {
        log.info("Attempting to send SMS notification for notification ID: {}",
                notification.getId() != null ? notification.getId() : "N/A");

        // Fetch user preferences
        NotificationPreferences preferences = preferencesRepository.findById(notification.getUserId())
                .orElse(null);

        // Validate preferences and SMS settings
        if (preferences == null || !preferences.isSmsNotificationsEnabled()) {
            log.warn("SMS notifications disabled or no preferences found for user: {}",
                    notification.getUserId());
            return false;
        }

        // Validate phone number
        if (preferences.getPhoneNumber() == null || preferences.getPhoneNumber().isEmpty()) {
            log.warn("No phone number found for user: {}", notification.getUserId());
            return false;
        }

        try {
            // If smsText is null, use message from notification
            String finalSmsText = smsText != null ? smsText : notification.getMessage();

            // Send SMS through the provider
            SmsProvider smsProvider = new SmsProvider();
            String messageSid = smsProvider.sendSms(preferences.getPhoneNumber(), finalSmsText);

            // Check if the message was sent successfully
            boolean success = messageSid != null;

            if (success) {
                log.info("SMS notification sent successfully: {}, SID: {}",
                        notification.getId(), messageSid);
            } else {
                log.error("Failed to send SMS notification: {}", notification.getId());
            }

            return success;
        } catch (Exception e) {
            log.error("Error sending SMS notification: {}. Error: {}",
                    notification.getId(), e.getMessage(), e);
            return false;
        }
    }

    /**
     * Sends a push notification
     */
    public boolean sendPushNotification(Notification notification) {
        log.info("Attempting to send push notification for notification ID: {}",
                notification.getId() != null ? notification.getId() : "N/A");

        // Fetch user preferences
        NotificationPreferences preferences = preferencesRepository.findById(notification.getUserId())
                .orElse(null);

        // Validate preferences and push notification settings
        if (preferences == null) {
            log.warn("No preferences found for user: {}", notification.getUserId());
            return false;
        }

        // Check if push notifications are enabled for this user
        if (!preferences.isPushNotificationsEnabled()) {
            log.info("Push notifications disabled for user: {}", notification.getUserId());
            return false;
        }

        // Validate device token
        if (preferences.getDeviceToken() == null || preferences.getDeviceToken().isEmpty()) {
            log.warn("No device token found for user: {}", notification.getUserId());
            return false;
        }

        // Validate Firebase messaging
        if (firebaseMessaging == null) {
            log.error("Firebase Messaging is not initialized. Push notification cannot be sent.");
            return false;
        }

        try {
            // Prepare notification data
            Map<String, String> data = prepareNotificationData(notification);

            // Create Firebase message
            Message message = buildFirebaseMessage(preferences.getDeviceToken(), notification, data);

            // Send message
            String messageId = firebaseMessaging.send(message);

            log.info("Push notification sent successfully. Message ID: {}, Notification ID: {}",
                    messageId, notification.getId());
            return true;
        } catch (FirebaseMessagingException e) {
            log.error("Firebase Messaging error when sending push notification for notification ID: {}. Error: {}",
                    notification.getId(), e.getMessage(), e);
            return false;
        } catch (Exception e) {
            log.error("Unexpected error when sending push notification for notification ID: {}. Error: {}",
                    notification.getId(), e.getMessage(), e);
            return false;
        }
    }

    /**
     * Prepares notification data for Firebase message
     */
    private Map<String, String> prepareNotificationData(Notification notification) {
        Map<String, String> data = new HashMap<>();
        data.put("notificationId",
                notification.getId() != null ? notification.getId().toString() : "");
        data.put("title", notification.getTitle());
        data.put("body", notification.getMessage());
        data.put("type", notification.getType().toString());
        data.put("category", notification.getCategory());

        if (notification.getReferenceId() != null) {
            data.put("referenceId", notification.getReferenceId());
        }

        if (notification.getActionUrl() != null) {
            data.put("actionUrl", notification.getActionUrl());
        }

        return data;
    }

    /**
     * Builds Firebase message with given device token, notification, and data
     */
    private Message buildFirebaseMessage(String deviceToken, Notification notification, Map<String, String> data) {
        return Message.builder()
                .setToken(deviceToken)
                .setNotification(com.google.firebase.messaging.Notification.builder()
                        .setTitle(notification.getTitle())
                        .setBody(notification.getMessage())
                        .build())
                .putAllData(data)
                .build();
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/service/TwoFactorNotificationService.java

**Dependencies:**
- Internal: `notification-service/src/main/java/com/waqiti/notification/domain/DeliveryStatus.java`, `notification-service/src/main/java/com/waqiti/notification/domain/Notification.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java` and 3 more
- External: `java.time.LocalDateTime`, `java.util.HashMap`, `java.util.Map` and 5 more

```java
// File: services/notification-service/src/main/java/com/waqiti/notification/service/TwoFactorNotificationService.java
package com.waqiti.notification.service;

import com.waqiti.notification.domain.Notification;
import com.waqiti.notification.domain.NotificationType;
import com.waqiti.notification.domain.DeliveryStatus;
import com.waqiti.notification.domain.NotificationTemplate;
import com.waqiti.notification.repository.NotificationRepository;
import com.waqiti.notification.service.provider.SmsProvider;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class TwoFactorNotificationService {

    private final NotificationService notificationService;
    private final NotificationTemplateService templateService;
    private final NotificationRepository notificationRepository;
    private final SmsProvider smsProvider;

    private static final String TWO_FACTOR_TEMPLATE_CODE = "two_factor_code";
    private static final String TWO_FACTOR_CATEGORY = "SECURITY";

    /**
     * Sends a 2FA verification code via SMS
     *
     * @param userId The user ID
     * @param phoneNumber The phone number to send the code to
     * @param verificationCode The verification code
     * @return true if the SMS was sent successfully, false otherwise
     */
    @Transactional
    public boolean sendTwoFactorSms(UUID userId, String phoneNumber, String verificationCode) {
        log.info("Sending 2FA verification code to user: {}", userId);

        try {
            // Try to get the template
            NotificationTemplate template;
            try {
                template = templateService.getTemplateByCode(TWO_FACTOR_TEMPLATE_CODE);
            } catch (IllegalArgumentException e) {
                // Template doesn't exist, use a default message
                log.warn("2FA template not found, using default message");
                return sendDirectTwoFactorSms(userId, phoneNumber, verificationCode);
            }

            // Prepare parameters for template
            Map<String, Object> params = new HashMap<>();
            params.put("code", verificationCode);

            // Create notification object
            Notification notification = Notification.create(
                    userId,
                    "Verification Code",
                    "Your verification code is: " + verificationCode,
                    NotificationType.SMS,
                    TWO_FACTOR_CATEGORY
            );

            // Set expiry to 10 minutes from now
            notification.setExpiryDate(LocalDateTime.now().plusMinutes(10));

            // Save notification
            notification = notificationRepository.save(notification);

            // Render SMS text from template
            String smsText;
            if (template.getSmsTemplate() != null) {
                smsText = templateService.renderTemplate(template.getSmsTemplate(), params);
            } else {
                smsText = "Your Waqiti verification code is: " + verificationCode;
            }

            // Send SMS directly through provider
            String messageSid = smsProvider.sendSms(phoneNumber, smsText);

            // Update notification status
            if (messageSid != null) {
                notification.updateDeliveryStatus(DeliveryStatus.SENT, null);
                notificationRepository.save(notification);
                return true;
            } else {
                notification.updateDeliveryStatus(DeliveryStatus.FAILED, "Failed to send SMS");
                notificationRepository.save(notification);
                return false;
            }
        } catch (Exception e) {
            log.error("Error sending 2FA SMS notification to user: {}. Error: {}",
                    userId, e.getMessage(), e);
            return false;
        }
    }

    /**
     * Sends a 2FA verification code directly via SMS without using templates
     */
    private boolean sendDirectTwoFactorSms(UUID userId, String phoneNumber, String verificationCode) {
        try {
            // Create a simple message
            String message = "Your Waqiti verification code is: " + verificationCode;

            // Create notification object
            Notification notification = Notification.create(
                    userId,
                    "Verification Code",
                    message,
                    NotificationType.SMS,
                    TWO_FACTOR_CATEGORY
            );

            // Set expiry to 10 minutes from now
            notification.setExpiryDate(LocalDateTime.now().plusMinutes(10));

            // Save notification
            notification = notificationRepository.save(notification);

            // Send SMS directly through provider
            String messageSid = smsProvider.sendSms(phoneNumber, message);

            // Update notification status
            if (messageSid != null) {
                notification.updateDeliveryStatus(DeliveryStatus.SENT, null);
                notificationRepository.save(notification);
                return true;
            } else {
                notification.updateDeliveryStatus(DeliveryStatus.FAILED, "Failed to send SMS");
                notificationRepository.save(notification);
                return false;
            }
        } catch (Exception e) {
            log.error("Error sending direct 2FA SMS notification to user: {}. Error: {}",
                    userId, e.getMessage(), e);
            return false;
        }
    }

    /**
     * Sends a 2FA verification code via email
     *
     * @param userId The user ID
     * @param email The email address to send the code to
     * @param verificationCode The verification code
     * @return true if the email was sent successfully, false otherwise
     */
    @Transactional
    public boolean sendTwoFactorEmail(UUID userId, String email, String verificationCode) {
        log.info("Sending 2FA verification code via email to user: {}", userId);

        // Create parameters for the notification
        Map<String, Object> params = new HashMap<>();
        params.put("code", verificationCode);

        // Use the notification service to send an email based on the template
        try {
            // Send notification using the template
            notificationService.sendNotification(
                    buildTwoFactorEmailRequest(userId, email, verificationCode)
            );
            return true;
        } catch (Exception e) {
            log.error("Error sending 2FA email notification to user: {}. Error: {}",
                    userId, e.getMessage(), e);
            return false;
        }
    }

    /**
     * Builds a SendNotificationRequest for 2FA emails
     */
    private com.waqiti.notification.dto.SendNotificationRequest buildTwoFactorEmailRequest(
            UUID userId, String email, String verificationCode) {

        Map<String, Object> params = new HashMap<>();
        params.put("code", verificationCode);
        params.put("email", email);

        return com.waqiti.notification.dto.SendNotificationRequest.builder()
                .userId(userId)
                .templateCode("two_factor_email")
                .parameters(params)
                .types(new String[] { "EMAIL" })
                .expiresAt(LocalDateTime.now().plusMinutes(10))
                .build();
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/service/NotificationPreferencesService.java

**Dependencies:**
- Internal: `notification-service/src/main/java/com/waqiti/notification/domain/NotificationPreferences.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationType.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationPreferencesResponse.java` and 2 more
- External: `java.util.Map`, `java.util.UUID`, `lombok.RequiredArgsConstructor` and 3 more

```java
package com.waqiti.notification.service;

import com.waqiti.notification.domain.NotificationPreferences;
import com.waqiti.notification.domain.NotificationType;
import com.waqiti.notification.dto.NotificationPreferencesResponse;
import com.waqiti.notification.dto.UpdatePreferencesRequest;
import com.waqiti.notification.repository.NotificationPreferencesRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Map;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationPreferencesService {
    private final NotificationPreferencesRepository preferencesRepository;

    /**
     * Gets or creates notification preferences for a user
     */
    @Transactional
    public NotificationPreferences getOrCreatePreferences(UUID userId) {
        log.info("Getting or creating notification preferences for user: {}", userId);

        return preferencesRepository.findById(userId)
                .orElseGet(() -> {
                    NotificationPreferences preferences = NotificationPreferences.createDefault(userId);
                    return preferencesRepository.save(preferences);
                });
    }

    /**
     * Updates notification preferences for a user
     */
    @Transactional
    public NotificationPreferencesResponse updatePreferences(UUID userId, UpdatePreferencesRequest request) {
        log.info("Updating notification preferences for user: {}", userId);

        NotificationPreferences preferences = getOrCreatePreferences(userId);

        // Update channel preferences
        if (request.getAppNotificationsEnabled() != null) {
            preferences.setAppNotificationsEnabled(request.getAppNotificationsEnabled());
        }

        if (request.getEmailNotificationsEnabled() != null) {
            preferences.setEmailNotificationsEnabled(request.getEmailNotificationsEnabled());
        }

        if (request.getSmsNotificationsEnabled() != null) {
            preferences.setSmsNotificationsEnabled(request.getSmsNotificationsEnabled());
        }

        if (request.getPushNotificationsEnabled() != null) {
            preferences.setPushNotificationsEnabled(request.getPushNotificationsEnabled());
        }

        // Update category preferences
        if (request.getCategoryPreferences() != null) {
            for (Map.Entry<String, Boolean> entry : request.getCategoryPreferences().entrySet()) {
                preferences.setCategoryPreference(entry.getKey(), entry.getValue());
            }
        }

        // Update quiet hours
        if (request.getQuietHoursStart() != null || request.getQuietHoursEnd() != null) {
            Integer start = request.getQuietHoursStart() != null ?
                    request.getQuietHoursStart() : preferences.getQuietHoursStart();
            Integer end = request.getQuietHoursEnd() != null ?
                    request.getQuietHoursEnd() : preferences.getQuietHoursEnd();

            preferences.setQuietHours(start, end);
        }

        // Update contact info
        if (request.getEmail() != null || request.getPhoneNumber() != null || request.getDeviceToken() != null) {
            preferences.updateContactInfo(
                    request.getEmail(),
                    request.getPhoneNumber(),
                    request.getDeviceToken()
            );
        }

        preferences = preferencesRepository.save(preferences);

        return mapToPreferencesResponse(preferences);
    }

    /**
     * Gets notification preferences for a user
     */
    @Transactional(readOnly = true)
    public NotificationPreferencesResponse getPreferences(UUID userId) {
        log.info("Getting notification preferences for user: {}", userId);

        NotificationPreferences preferences = getOrCreatePreferences(userId);

        return mapToPreferencesResponse(preferences);
    }

    /**
     * Checks if a notification type is enabled for a user and category
     */
    @Transactional(readOnly = true)
    public boolean isNotificationEnabled(UUID userId, String category, NotificationType type) {
        log.debug("Checking if notification is enabled for user: {}, category: {}, type: {}",
                userId, category, type);

        NotificationPreferences preferences = getOrCreatePreferences(userId);

        // Check if quiet hours
        if (preferences.isQuietHours()) {
            // During quiet hours, only allow app notifications
            return type == NotificationType.APP && preferences.isAppNotificationsEnabled() &&
                    preferences.shouldSendNotification(category, type);
        }

        return preferences.shouldSendNotification(category, type);
    }

    /**
     * Updates device token for push notifications
     */
    @Transactional
    public void updateDeviceToken(UUID userId, String deviceToken) {
        log.info("Updating device token for user: {}", userId);

        NotificationPreferences preferences = getOrCreatePreferences(userId);

        preferences.updateContactInfo(null, null, deviceToken);
        preferences.setPushNotificationsEnabled(true);

        preferencesRepository.save(preferences);
    }

    /**
     * Updates email address
     */
    @Transactional
    public void updateEmail(UUID userId, String email) {
        log.info("Updating email for user: {}", userId);

        NotificationPreferences preferences = getOrCreatePreferences(userId);

        preferences.updateContactInfo(email, null, null);

        preferencesRepository.save(preferences);
    }

    /**
     * Updates phone number
     */
    @Transactional
    public void updatePhoneNumber(UUID userId, String phoneNumber) {
        log.info("Updating phone number for user: {}", userId);

        NotificationPreferences preferences = getOrCreatePreferences(userId);

        preferences.updateContactInfo(null, phoneNumber, null);

        preferencesRepository.save(preferences);
    }

    /**
     * Maps a NotificationPreferences entity to a NotificationPreferencesResponse DTO
     */
    private NotificationPreferencesResponse mapToPreferencesResponse(NotificationPreferences preferences) {
        return NotificationPreferencesResponse.builder()
                .userId(preferences.getUserId())
                .appNotificationsEnabled(preferences.isAppNotificationsEnabled())
                .emailNotificationsEnabled(preferences.isEmailNotificationsEnabled())
                .smsNotificationsEnabled(preferences.isSmsNotificationsEnabled())
                .pushNotificationsEnabled(preferences.isPushNotificationsEnabled())
                .categoryPreferences(preferences.getCategoryPreferences())
                .quietHoursStart(preferences.getQuietHoursStart())
                .quietHoursEnd(preferences.getQuietHoursEnd())
                .email(preferences.getEmail())
                .phoneNumber(preferences.getPhoneNumber())
                .deviceTokenRegistered(preferences.getDeviceToken() != null)
                .updatedAt(preferences.getUpdatedAt())
                .build();
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/service/NotificationService.java

**Dependencies:**
- Internal: `notification-service/src/main/java/com/waqiti/notification/domain/DeliveryStatus.java`, `notification-service/src/main/java/com/waqiti/notification/domain/Notification.java`, `notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java` and 5 more
- External: `com.waqiti.notification.domain.`, `java.time.LocalDateTime`, `java.util.` and 8 more

```java
/**
 * File: src/main/java/com/waqiti/notification/service/NotificationService.java
 */
package com.waqiti.notification.service;

import com.waqiti.notification.domain.*;
import com.waqiti.notification.domain.DeliveryStatus;
import com.waqiti.notification.domain.Notification;
import com.waqiti.notification.domain.NotificationTemplate;
import com.waqiti.notification.domain.NotificationType;
import com.waqiti.notification.dto.NotificationListResponse;
import com.waqiti.notification.dto.NotificationResponse;
import com.waqiti.notification.dto.SendNotificationRequest;
import com.waqiti.notification.repository.NotificationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationService {
    private final NotificationRepository notificationRepository;
    private final NotificationTemplateService templateService;
    private final NotificationPreferencesService preferencesService;
    private final NotificationSenderService senderService;

    /**
     * Sends a notification using a template
     */
    @Transactional
    public List<NotificationResponse> sendNotification(SendNotificationRequest request) {
        log.info("Sending notification to user: {}, template: {}",
                request.getUserId(), request.getTemplateCode());

        // Get the template
        NotificationTemplate template = templateService.getTemplateByCode(request.getTemplateCode());

        if (!template.isEnabled()) {
            log.warn("Template is disabled: {}", request.getTemplateCode());
            return List.of();
        }

        // Render the templates
        String title = templateService.renderTemplate(template.getTitleTemplate(), request.getParameters());
        String message = templateService.renderTemplate(template.getMessageTemplate(), request.getParameters());

        // Determine which notification types to send based on request and user preferences
        List<NotificationType> typesToSend = determineNotificationTypes(
                request.getUserId(), template.getCategory(), request.getTypes());

        if (typesToSend.isEmpty()) {
            log.info("No notification types enabled for user: {}, template: {}",
                    request.getUserId(), request.getTemplateCode());
            return List.of();
        }

        // Create and send notifications for each type
        List<Notification> notifications = new ArrayList<>();

        for (NotificationType type : typesToSend) {
            // Create the notification
            Notification notification = Notification.create(
                    request.getUserId(), title, message, type, template.getCategory());

            if (request.getReferenceId() != null) {
                notification.setReferenceId(request.getReferenceId());
            }

            if (request.getActionUrl() != null) {
                notification.setActionUrl(request.getActionUrl());
            } else if (template.getActionUrlTemplate() != null) {
                String renderedActionUrl = templateService.renderTemplate(
                        template.getActionUrlTemplate(), request.getParameters());
                notification.setActionUrl(renderedActionUrl);
            }

            if (request.getExpiresAt() != null) {
                notification.setExpiryDate(request.getExpiresAt());
            }

            // Save the initial notification to get an ID
            notification = notificationRepository.save(notification);

            // Process and send the notification
            processNotification(notification, type, template, request.getParameters());

            notifications.add(notification);
        }

        return notifications.stream()
                .map(this::mapToNotificationResponse)
                .collect(Collectors.toList());
    }

    /**
     * Process and send a notification
     */
    private void processNotification(Notification notification,
                                     NotificationType type,
                                     NotificationTemplate template,
                                     Map<String, Object> parameters) {
        try {
            boolean sent = false;

            switch (type) {
                case APP -> sent = true; // App notifications are always "sent" as they're stored in DB
                case EMAIL -> sent = senderService.sendEmailNotification(
                        notification,
                        templateService.renderTemplate(template.getEmailSubjectTemplate(), parameters),
                        templateService.renderTemplate(template.getEmailBodyTemplate(), parameters));
                case SMS -> sent = senderService.sendSmsNotification(
                        notification,
                        templateService.renderTemplate(template.getSmsTemplate(), parameters));
                case PUSH -> sent = senderService.sendPushNotification(notification);
            }

            // Update delivery status
            if (sent) {
                notification.updateDeliveryStatus(DeliveryStatus.SENT, null);
            } else {
                notification.updateDeliveryStatus(
                        DeliveryStatus.FAILED, "Failed to send notification");
            }
        } catch (Exception e) {
            log.error("Error sending notification", e);
            notification.updateDeliveryStatus(
                    DeliveryStatus.FAILED, e.getMessage());
        }
    }

    /**
     * Determines which notification types to send based on user preferences
     * Made package-private for testability while maintaining encapsulation
     */
    /* package */ List<NotificationType> determineNotificationTypes(UUID userId,
                                                                    String category,
                                                                    String[] requestedTypes) {
        // Use a mutable list instead of immutable List.of()
        List<NotificationType> enabledTypes = new ArrayList<>();

        // If specific types are requested, use those (still check preferences)
        if (requestedTypes != null && requestedTypes.length > 0) {
            return Arrays.stream(requestedTypes)
                    .map(NotificationType::valueOf)
                    .filter(type -> preferencesService.isNotificationEnabled(userId, category, type))
                    .collect(Collectors.toList());
        }

        // Otherwise, determine based on user preferences
        for (NotificationType type : NotificationType.values()) {
            if (preferencesService.isNotificationEnabled(userId, category, type)) {
                enabledTypes.add(type);
            }
        }

        return enabledTypes;
    }

    /**
     * Gets notifications for a user
     */
    @Transactional(readOnly = true)
    public NotificationListResponse getNotifications(UUID userId, Pageable pageable) {
        log.info("Getting notifications for user: {}", userId);

        Page<Notification> notificationsPage =
                notificationRepository.findByUserIdOrderByCreatedAtDesc(userId, pageable);

        long unreadCount = notificationRepository.countByUserIdAndReadFalse(userId);

        List<NotificationResponse> notifications = notificationsPage.getContent().stream()
                .map(this::mapToNotificationResponse)
                .collect(Collectors.toList());

        // Handle unpaged Pageable safely
        int pageNumber = pageable.isPaged() ? pageable.getPageNumber() : 0;
        int pageSize = pageable.isPaged() ? pageable.getPageSize() : notifications.size();

        return NotificationListResponse.builder()
                .notifications(notifications)
                .unreadCount(unreadCount)
                .totalPages(notificationsPage.getTotalPages())
                .totalElements(notificationsPage.getTotalElements())
                .page(pageNumber)
                .size(pageSize)
                .build();
    }

    /**
     * Gets unread notifications for a user
     */
    @Transactional(readOnly = true)
    public NotificationListResponse getUnreadNotifications(UUID userId, Pageable pageable) {
        log.info("Getting unread notifications for user: {}", userId);

        Page<Notification> notificationsPage =
                notificationRepository.findByUserIdAndReadFalseOrderByCreatedAtDesc(userId, pageable);

        long unreadCount = notificationsPage.getTotalElements();

        List<NotificationResponse> notifications = notificationsPage.getContent().stream()
                .map(this::mapToNotificationResponse)
                .collect(Collectors.toList());

        // Handle unpaged Pageable safely
        int pageNumber = pageable.isPaged() ? pageable.getPageNumber() : 0;
        int pageSize = pageable.isPaged() ? pageable.getPageSize() : notifications.size();

        return NotificationListResponse.builder()
                .notifications(notifications)
                .unreadCount(unreadCount)
                .totalPages(notificationsPage.getTotalPages())
                .totalElements(notificationsPage.getTotalElements())
                .page(pageNumber)
                .size(pageSize)
                .build();
    }

    /**
     * Gets a notification by ID
     */
    @Transactional(readOnly = true)
    public NotificationResponse getNotification(UUID id) {
        log.info("Getting notification with ID: {}", id);

        Notification notification = notificationRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Notification not found with ID: " + id));

        return mapToNotificationResponse(notification);
    }

    /**
     * Marks a notification as read
     */
    @Transactional
    public NotificationResponse markAsRead(UUID id) {
        log.info("Marking notification as read: {}", id);

        Notification notification = notificationRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Notification not found with ID: " + id));

        notification.markAsRead();
        notification = notificationRepository.save(notification);

        return mapToNotificationResponse(notification);
    }

    /**
     * Marks all notifications as read for a user
     */
    @Transactional
    public void markAllAsRead(UUID userId) {
        log.info("Marking all notifications as read for user: {}", userId);

        Page<Notification> unreadNotifications =
                notificationRepository.findByUserIdAndReadFalseOrderByCreatedAtDesc(
                        userId, Pageable.unpaged());

        for (Notification notification : unreadNotifications) {
            notification.markAsRead();
            notificationRepository.save(notification);
        }
    }

    /**
     * Scheduled task to retry failed notifications
     */
    @Scheduled(fixedDelay = 60000) // Every minute
    @Transactional
    public void retryFailedNotifications() {
        log.info("Retrying failed notifications");

        List<Notification> failedNotifications =
                notificationRepository.findByDeliveryStatus(DeliveryStatus.FAILED);

        for (Notification notification : failedNotifications) {
            try {
                boolean sent = false;

                switch (notification.getType()) {
                    case APP -> sent = true;
                    case EMAIL -> sent = senderService.sendEmailNotification(notification, null, null);
                    case SMS -> sent = senderService.sendSmsNotification(notification, null);
                    case PUSH -> sent = senderService.sendPushNotification(notification);
                }

                if (sent) {
                    notification.updateDeliveryStatus(DeliveryStatus.SENT, null);
                    notificationRepository.save(notification);
                }
            } catch (Exception e) {
                log.error("Error retrying notification: {}", notification.getId(), e);
            }
        }
    }

    /**
     * Scheduled task to clean up expired notifications
     */
    @Scheduled(cron = "0 0 0 * * *") // Every day at midnight
    @Transactional
    public void cleanupExpiredNotifications() {
        log.info("Cleaning up expired notifications");

        List<Notification> expiredNotifications =
                notificationRepository.findByReadFalseAndExpiresAtBeforeAndDeliveryStatus(
                        LocalDateTime.now(), DeliveryStatus.SENT);

        for (Notification notification : expiredNotifications) {
            notification.updateDeliveryStatus(DeliveryStatus.EXPIRED, "Notification expired");
            notificationRepository.save(notification);
        }
    }

    /**
     * Maps a Notification entity to a NotificationResponse DTO
     */
    private NotificationResponse mapToNotificationResponse(Notification notification) {
        return NotificationResponse.builder()
                .id(notification.getId())
                .userId(notification.getUserId())
                .title(notification.getTitle())
                .message(notification.getMessage())
                .type(notification.getType().toString())
                .category(notification.getCategory())
                .referenceId(notification.getReferenceId())
                .read(notification.isRead())
                .actionUrl(notification.getActionUrl())
                .createdAt(notification.getCreatedAt())
                .expiresAt(notification.getExpiresAt())
                .readAt(notification.getReadAt())
                .deliveryStatus(notification.getDeliveryStatus().toString())
                .build();
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/service/TemplateRenderer.java

**Dependencies:**
- External: `java.util.Locale`, `java.util.Map`, `lombok.RequiredArgsConstructor` and 4 more

```java
package com.waqiti.notification.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.thymeleaf.ITemplateEngine;
import org.thymeleaf.context.Context;

import java.util.Locale;
import java.util.Map;

@Service
@RequiredArgsConstructor
@Slf4j
public class TemplateRenderer {
    private final ITemplateEngine templateEngine;

    /**
     * Renders a template string with the given model
     */
    public String renderTemplate(String template, Object model) {
        try {
            Context context = new Context(Locale.getDefault());

            if (model instanceof Map) {
                @SuppressWarnings("unchecked")
                Map<String, Object> modelMap = (Map<String, Object>) model;
                modelMap.forEach(context::setVariable);
            } else {
                context.setVariable("model", model);
            }

            // Wrap the template in Thymeleaf processing tags
            String wrappedTemplate = "<div th:remove=\"tag\">" + template + "</div>";

            return templateEngine.process(wrappedTemplate, context);
        } catch (Exception e) {
            log.error("Error rendering template: {}", template, e);
            // Return the original template in case of an error
            return template;
        }
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/service/NotificationTemplateService.java

**Dependencies:**
- Internal: `notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationTemplateRequest.java`, `notification-service/src/main/java/com/waqiti/notification/dto/NotificationTemplateResponse.java` and 1 more
- External: `java.util.List`, `java.util.UUID`, `java.util.stream.Collectors` and 6 more

```java
package com.waqiti.notification.service;

import com.waqiti.notification.domain.NotificationTemplate;
import com.waqiti.notification.dto.NotificationTemplateRequest;
import com.waqiti.notification.dto.NotificationTemplateResponse;
import com.waqiti.notification.repository.NotificationTemplateRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationTemplateService {
    private final NotificationTemplateRepository templateRepository;
    private final TemplateRenderer templateRenderer;

    /**
     * Creates a new notification template
     */
    @Transactional
    @CacheEvict(value = "templates", allEntries = true)
    public NotificationTemplateResponse createTemplate(NotificationTemplateRequest request) {
        log.info("Creating notification template with code: {}", request.getCode());

        // Check if code already exists
        if (templateRepository.existsByCode(request.getCode())) {
            throw new IllegalArgumentException("Template with code already exists: " + request.getCode());
        }

        // Create the template
        NotificationTemplate template = NotificationTemplate.create(
                request.getCode(),
                request.getName(),
                request.getCategory(),
                request.getTitleTemplate(),
                request.getMessageTemplate()
        );

        // Set optional fields
        if (request.getEmailSubjectTemplate() != null) {
            template.setEmailTemplates(
                    request.getEmailSubjectTemplate(),
                    request.getEmailBodyTemplate()
            );
        }

        if (request.getSmsTemplate() != null) {
            template.setSmsTemplate(request.getSmsTemplate());
        }

        if (request.getActionUrlTemplate() != null) {
            template.setActionUrlTemplate(request.getActionUrlTemplate());
        }

        template.setEnabled(request.isEnabled());

        template = templateRepository.save(template);

        return mapToTemplateResponse(template);
    }

    /**
     * Updates an existing notification template
     */
    @Transactional
    @CacheEvict(value = "templates", allEntries = true)
    public NotificationTemplateResponse updateTemplate(UUID id, NotificationTemplateRequest request) {
        log.info("Updating notification template with ID: {}", id);

        NotificationTemplate template = templateRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Template not found with ID: " + id));

        // Update basic fields
        template.updateContent(request.getTitleTemplate(), request.getMessageTemplate());

        // Update optional fields
        if (request.getEmailSubjectTemplate() != null) {
            template.setEmailTemplates(
                    request.getEmailSubjectTemplate(),
                    request.getEmailBodyTemplate()
            );
        }

        if (request.getSmsTemplate() != null) {
            template.setSmsTemplate(request.getSmsTemplate());
        }

        if (request.getActionUrlTemplate() != null) {
            template.setActionUrlTemplate(request.getActionUrlTemplate());
        }

        template.setEnabled(request.isEnabled());

        template = templateRepository.save(template);

        return mapToTemplateResponse(template);
    }

    /**
     * Gets a template by ID
     */
    @Transactional(readOnly = true)
    public NotificationTemplateResponse getTemplateById(UUID id) {
        log.info("Getting notification template with ID: {}", id);

        NotificationTemplate template = templateRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Template not found with ID: " + id));

        return mapToTemplateResponse(template);
    }

    /**
     * Gets a template by code
     */
    @Transactional(readOnly = true)
    @Cacheable(value = "templates", key = "#code")
    public NotificationTemplate getTemplateByCode(String code) {
        log.info("Getting notification template with code: {}", code);

        return templateRepository.findByCode(code)
                .orElseThrow(() -> new IllegalArgumentException("Template not found with code: " + code));
    }

    /**
     * Gets all templates
     */
    @Transactional(readOnly = true)
    public List<NotificationTemplateResponse> getAllTemplates() {
        log.info("Getting all notification templates");

        List<NotificationTemplate> templates = templateRepository.findAll();

        return templates.stream()
                .map(this::mapToTemplateResponse)
                .collect(Collectors.toList());
    }

    /**
     * Gets templates by category
     */
    @Transactional(readOnly = true)
    public List<NotificationTemplateResponse> getTemplatesByCategory(String category) {
        log.info("Getting notification templates for category: {}", category);

        List<NotificationTemplate> templates = templateRepository.findByCategory(category);

        return templates.stream()
                .map(this::mapToTemplateResponse)
                .collect(Collectors.toList());
    }

    /**
     * Enables or disables a template
     */
    @Transactional
    @CacheEvict(value = "templates", allEntries = true)
    public NotificationTemplateResponse setTemplateEnabled(UUID id, boolean enabled) {
        log.info("Setting template {} to enabled={}", id, enabled);

        NotificationTemplate template = templateRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Template not found with ID: " + id));

        template.setEnabled(enabled);
        template = templateRepository.save(template);

        return mapToTemplateResponse(template);
    }

    /**
     * Renders a template with the given parameters
     */
    public String renderTemplate(String template, Object model) {
        return templateRenderer.renderTemplate(template, model);
    }

    /**
     * Maps a NotificationTemplate entity to a NotificationTemplateResponse DTO
     */
    private NotificationTemplateResponse mapToTemplateResponse(NotificationTemplate template) {
        return NotificationTemplateResponse.builder()
                .id(template.getId())
                .code(template.getCode())
                .name(template.getName())
                .category(template.getCategory())
                .titleTemplate(template.getTitleTemplate())
                .messageTemplate(template.getMessageTemplate())
                .emailSubjectTemplate(template.getEmailSubjectTemplate())
                .emailBodyTemplate(template.getEmailBodyTemplate())
                .smsTemplate(template.getSmsTemplate())
                .actionUrlTemplate(template.getActionUrlTemplate())
                .enabled(template.isEnabled())
                .createdAt(template.getCreatedAt())
                .updatedAt(template.getUpdatedAt())
                .build();
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/service/provider/SmsProvider.java

**Dependencies:**
- External: `com.twilio.Twilio`, `com.twilio.rest.api.v2010.account.Message`, `com.twilio.type.PhoneNumber` and 3 more

```java
// File: services/notification-service/src/main/java/com/waqiti/notification/service/provider/SmsProvider.java
package com.waqiti.notification.service.provider;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import com.twilio.Twilio;
import com.twilio.rest.api.v2010.account.Message;
import com.twilio.type.PhoneNumber;

/**
 * Provider for SMS notifications using Twilio
 */
@Service
@Slf4j
public class SmsProvider {

    @Value("${notification.sms.from}")
    private String fromNumber;

    @Value("${twilio.account.sid}")
    private String accountSid;

    @Value("${twilio.auth.token}")
    private String authToken;

    @Value("${twilio.enabled:false}")
    private boolean twilioEnabled;

    /**
     * Initializes Twilio client on service startup
     */
    public void init() {
        if (twilioEnabled) {
            try {
                log.info("Initializing Twilio SMS provider with account SID: {}", maskSid(accountSid));
                Twilio.init(accountSid, authToken);
                log.info("Twilio SMS provider initialized successfully");
            } catch (Exception e) {
                log.error("Failed to initialize Twilio SMS provider", e);
            }
        } else {
            log.info("Twilio SMS provider is disabled");
        }
    }

    /**
     * Sends an SMS message to the specified phone number
     *
     * @param to The recipient's phone number (E.164 format)
     * @param messageText The message text to send
     * @return The message SID if successful, null otherwise
     */
    public String sendSms(String to, String messageText) {
        if (!twilioEnabled) {
            log.info("SMS sending skipped as Twilio is disabled. Would send to: {}, message: {}",
                    to, messageText);
            return "DISABLED";
        }

        try {
            log.info("Sending SMS to: {}", to);
            Message message = Message.creator(
                    new PhoneNumber(to),
                    new PhoneNumber(fromNumber),
                    messageText
            ).create();

            log.info("SMS sent successfully with SID: {}", message.getSid());
            return message.getSid();
        } catch (Exception e) {
            log.error("Failed to send SMS to {}: {}", to, e.getMessage(), e);
            return null;
        }
    }

    /**
     * Mask most of the SID for security in logs
     */
    private String maskSid(String sid) {
        if (sid == null || sid.length() < 8) {
            return "***";
        }
        return sid.substring(0, 4) + "..." + sid.substring(sid.length() - 4);
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/domain/NotificationCategory.java

```java
package com.waqiti.notification.domain;

/**
 * Represents the categories of notifications
 */
public enum NotificationCategory {
    ACCOUNT,            // Account-related notifications (registration, verification, etc.)
    TRANSACTION,        // Transaction-related notifications (deposits, withdrawals, transfers)
    PAYMENT_REQUEST,    // Payment request notifications
    SCHEDULED_PAYMENT,  // Scheduled payment notifications
    SPLIT_PAYMENT,      // Split payment notifications
    SECURITY            // Security-related notifications (login, password change, etc.)
}
```

### notification-service/src/main/java/com/waqiti/notification/domain/NotificationPreferences.java

**Dependencies:**
- External: `jakarta.persistence.`, `java.time.LocalDateTime`, `java.util.HashMap` and 6 more

```java
package com.waqiti.notification.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Entity
@Table(name = "notification_preferences")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class NotificationPreferences {
    @Id
    private UUID userId;

    @Column(nullable = false)
    private boolean appNotificationsEnabled;

    @Column(nullable = false)
    private boolean emailNotificationsEnabled;

    @Column(nullable = false)
    private boolean smsNotificationsEnabled;

    @Column(nullable = false)
    private boolean pushNotificationsEnabled;

    @ElementCollection
    @CollectionTable(name = "category_preferences",
            joinColumns = @JoinColumn(name = "user_id"))
    @MapKeyColumn(name = "category")
    @Column(name = "enabled")
    private Map<String, Boolean> categoryPreferences = new HashMap<>();

    @Column(name = "quiet_hours_start")
    private Integer quietHoursStart;

    @Column(name = "quiet_hours_end")
    private Integer quietHoursEnd;

    @Column(name = "email")
    private String email;

    @Column(name = "phone_number")
    private String phoneNumber;

    @Column(name = "device_token")
    private String deviceToken;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @Version
    private Long version;

    // Audit fields
    @Setter
    @Column(name = "created_by")
    private String createdBy;

    @Setter
    @Column(name = "updated_by")
    private String updatedBy;

    /**
     * Creates default notification preferences for a user
     */
    public static NotificationPreferences createDefault(UUID userId) {
        NotificationPreferences preferences = new NotificationPreferences();
        preferences.userId = userId;
        preferences.appNotificationsEnabled = true;
        preferences.emailNotificationsEnabled = true;
        preferences.smsNotificationsEnabled = false;
        preferences.pushNotificationsEnabled = false;

        // Enable all categories by default
        for (NotificationCategory category : NotificationCategory.values()) {
            preferences.categoryPreferences.put(category.name(), true);
        }

        preferences.createdAt = LocalDateTime.now();
        preferences.updatedAt = LocalDateTime.now();

        return preferences;
    }

    /**
     * Updates the app notification setting
     */
    public void setAppNotificationsEnabled(boolean enabled) {
        this.appNotificationsEnabled = enabled;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates the email notification setting
     */
    public void setEmailNotificationsEnabled(boolean enabled) {
        this.emailNotificationsEnabled = enabled;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates the SMS notification setting
     */
    public void setSmsNotificationsEnabled(boolean enabled) {
        this.smsNotificationsEnabled = enabled;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates the push notification setting
     */
    public void setPushNotificationsEnabled(boolean enabled) {
        this.pushNotificationsEnabled = enabled;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates a category preference
     */
    public void setCategoryPreference(String category, boolean enabled) {
        this.categoryPreferences.put(category, enabled);
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates quiet hours
     */
    public void setQuietHours(Integer start, Integer end) {
        this.quietHoursStart = start;
        this.quietHoursEnd = end;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates contact information
     */
    public void updateContactInfo(String email, String phoneNumber, String deviceToken) {
        if (email != null) {
            this.email = email;
        }

        if (phoneNumber != null) {
            this.phoneNumber = phoneNumber;
        }

        if (deviceToken != null) {
            this.deviceToken = deviceToken;
        }

        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Checks if notifications should be sent based on category and type
     */
    public boolean shouldSendNotification(String category, NotificationType type) {
        // Check category preference
        Boolean categoryEnabled = categoryPreferences.get(category);
        if (categoryEnabled == null || !categoryEnabled) {
            return false;
        }

        // Check type preference
        switch (type) {
            case APP -> {
                return appNotificationsEnabled;
            }
            case EMAIL -> {
                return emailNotificationsEnabled && email != null && !email.isEmpty();
            }
            case SMS -> {
                return smsNotificationsEnabled && phoneNumber != null && !phoneNumber.isEmpty();
            }
            case PUSH -> {
                return pushNotificationsEnabled && deviceToken != null && !deviceToken.isEmpty();
            }
            default -> {
                return false;
            }
        }
    }

    /**
     * Checks if current time is within quiet hours
     */
    public boolean isQuietHours() {
        if (quietHoursStart == null || quietHoursEnd == null) {
            return false;
        }

        int currentHour = LocalDateTime.now().getHour();

        if (quietHoursStart <= quietHoursEnd) {
            // E.g., 22:00 - 06:00
            return currentHour >= quietHoursStart && currentHour < quietHoursEnd;
        } else {
            // E.g., 22:00 - 06:00 (spans midnight)
            return currentHour >= quietHoursStart || currentHour < quietHoursEnd;
        }
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/domain/Notification.java

**Dependencies:**
- External: `jakarta.persistence.`, `java.time.LocalDateTime`, `java.util.UUID` and 4 more

```java
package com.waqiti.notification.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "notifications")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false)
    private UUID userId;

    @Column(nullable = false, length = 100)
    private String title;

    @Column(nullable = false, length = 1000)
    private String message;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private NotificationType type;

    @Column(length = 100)
    private String category;

    @Column(name = "reference_id")
    private String referenceId;

    @Column(nullable = false)
    private boolean read;

    @Column(name = "action_url")
    private String actionUrl;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    @Column(name = "expires_at")
    private LocalDateTime expiresAt;

    @Column(name = "read_at")
    private LocalDateTime readAt;

    @Enumerated(EnumType.STRING)
    @Column(name = "delivery_status", nullable = false)
    private DeliveryStatus deliveryStatus;

    @Column(name = "delivery_error")
    private String deliveryError;

    @Version
    private Long version;

    // Audit fields
    @Setter
    @Column(name = "created_by")
    private String createdBy;

    /**
     * Creates a new notification
     */
    public static Notification create(UUID userId, String title, String message,
                                      NotificationType type, String category) {
        Notification notification = new Notification();
        notification.userId = userId;
        notification.title = title;
        notification.message = message;
        notification.type = type;
        notification.category = category;
        notification.read = false;
        notification.createdAt = LocalDateTime.now();
        notification.deliveryStatus = DeliveryStatus.PENDING;
        return notification;
    }

    /**
     * Marks the notification as read
     */
    public void markAsRead() {
        if (!this.read) {
            this.read = true;
            this.readAt = LocalDateTime.now();
        }
    }

    /**
     * Updates the delivery status
     */
    public void updateDeliveryStatus(DeliveryStatus status, String error) {
        this.deliveryStatus = status;
        this.deliveryError = error;
    }

    /**
     * Sets the reference ID
     */
    public void setReferenceId(String referenceId) {
        this.referenceId = referenceId;
    }

    /**
     * Sets the action URL
     */
    public void setActionUrl(String actionUrl) {
        this.actionUrl = actionUrl;
    }

    /**
     * Sets the expiry date
     */
    public void setExpiryDate(LocalDateTime expiresAt) {
        this.expiresAt = expiresAt;
    }

    /**
     * Checks if the notification is expired
     */
    public boolean isExpired() {
        return expiresAt != null && LocalDateTime.now().isAfter(expiresAt);
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/domain/DeliveryStatus.java

```java
/**
 * File: src/main/java/com/waqiti/notification/domain/DeliveryStatus.java
 */

package com.waqiti.notification.domain;

/**
 * Represents the delivery status of a notification
 */
public enum DeliveryStatus {
    PENDING,    // Notification is waiting to be delivered
    SENT,       // Notification has been sent
    DELIVERED,  // Notification has been delivered
    FAILED,      // Notification delivery failed
    EXPIRED     // Notification has expired
}
```

### notification-service/src/main/java/com/waqiti/notification/domain/NotificationTemplate.java

**Dependencies:**
- External: `jakarta.persistence.`, `java.time.LocalDateTime`, `java.util.UUID` and 4 more

```java
package com.waqiti.notification.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "notification_templates")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class NotificationTemplate {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false, unique = true)
    private String code;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, length = 100)
    private String category;

    @Column(nullable = false, length = 200)
    private String titleTemplate;

    @Column(nullable = false, length = 2000)
    private String messageTemplate;

    @Column(length = 2000)
    private String emailSubjectTemplate;

    @Column(length = 5000)
    private String emailBodyTemplate;

    @Column(length = 200)
    private String smsTemplate;

    @Column(name = "action_url_template")
    private String actionUrlTemplate;

    @Column(nullable = false)
    private boolean enabled;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    // Audit fields
    @Setter
    @Column(name = "created_by")
    private String createdBy;

    @Setter
    @Column(name = "updated_by")
    private String updatedBy;

    /**
     * Creates a new notification template
     */
    public static NotificationTemplate create(String code, String name, String category,
                                              String titleTemplate, String messageTemplate) {
        NotificationTemplate template = new NotificationTemplate();
        template.code = code;
        template.name = name;
        template.category = category;
        template.titleTemplate = titleTemplate;
        template.messageTemplate = messageTemplate;
        template.enabled = true;
        template.createdAt = LocalDateTime.now();
        template.updatedAt = LocalDateTime.now();
        return template;
    }

    /**
     * Sets the email templates
     */
    public void setEmailTemplates(String emailSubjectTemplate, String emailBodyTemplate) {
        this.emailSubjectTemplate = emailSubjectTemplate;
        this.emailBodyTemplate = emailBodyTemplate;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Sets the SMS template
     */
    public void setSmsTemplate(String smsTemplate) {
        this.smsTemplate = smsTemplate;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Sets the action URL template
     */
    public void setActionUrlTemplate(String actionUrlTemplate) {
        this.actionUrlTemplate = actionUrlTemplate;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Enables or disables the template
     */
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates the template content
     */
    public void updateContent(String titleTemplate, String messageTemplate) {
        this.titleTemplate = titleTemplate;
        this.messageTemplate = messageTemplate;
        this.updatedAt = LocalDateTime.now();
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/domain/NotificationType.java

```java
package com.waqiti.notification.domain;

/**
 * Represents the types of notifications
 */
public enum NotificationType {
    APP,        // In-app notification
    EMAIL,      // Email notification
    SMS,        // SMS notification
    PUSH        // Push notification to mobile device
}
```

### notification-service/src/main/java/com/waqiti/notification/messaging/NotificationEventListener.java

**Dependencies:**
- Internal: `notification-service/src/main/java/com/waqiti/notification/dto/SendNotificationRequest.java`, `notification-service/src/main/java/com/waqiti/notification/service/NotificationService.java`
- External: `com.fasterxml.jackson.databind.ObjectMapper`, `com.waqiti.notification.event.`, `java.util.HashMap` and 5 more

```java
/**
 * File: src/main/java/com/waqiti/notification/messaging/NotificationEventListener.java
 */
package com.waqiti.notification.messaging;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.waqiti.notification.dto.SendNotificationRequest;
import com.waqiti.notification.event.*;
import com.waqiti.notification.event.*;
import com.waqiti.notification.service.NotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;

@Component
@RequiredArgsConstructor
@Slf4j
public class NotificationEventListener {
    private final NotificationService notificationService;
    private final ObjectMapper objectMapper;

    // User event listeners

    @KafkaListener(topics = "user-events", groupId = "notification-service")
    public void consumeUserEvents(String message) {
        try {
            // Determine the event type
            NotificationEvent baseEvent = objectMapper.readValue(message, NotificationEvent.class);

            if (baseEvent == null || baseEvent.getEventType() == null) {
                log.warn("Invalid user event with null event type: {}", message);
                return;
            }

            switch (baseEvent.getEventType()) {
                case "USER_REGISTERED" -> handleUserRegisteredEvent(message);
                case "USER_VERIFIED" -> handleUserVerifiedEvent(message);
                default -> log.warn("Unknown user event type: {}", baseEvent.getEventType());
            }
        } catch (Exception e) {
            log.error("Error processing user event", e);
        }
    }

    private void handleUserRegisteredEvent(String message) throws Exception {
        UserRegisteredEvent event = objectMapper.readValue(message, UserRegisteredEvent.class);

        if (event == null || event.getUserId() == null) {
            log.warn("Invalid user registered event: {}", message);
            return;
        }

        // Initialize the event type if needed
        if (event.getEventType() == null) {
            event.setEventType("USER_REGISTERED");
        }

        log.info("Received user registered event for user: {}", event.getUserId());

        Map<String, Object> params = new HashMap<>();
        params.put("username", event.getUsername());

        SendNotificationRequest request = SendNotificationRequest.builder()
                .userId(event.getUserId())
                .templateCode("user_registered")
                .parameters(params)
                .types(new String[] { "EMAIL" }) // Force email notification for registration
                .build();

        notificationService.sendNotification(request);
    }

    private void handleUserVerifiedEvent(String message) throws Exception {
        UserVerifiedEvent event = objectMapper.readValue(message, UserVerifiedEvent.class);

        if (event == null || event.getUserId() == null) {
            log.warn("Invalid user verified event: {}", message);
            return;
        }

        // Initialize the event type if needed
        if (event.getEventType() == null) {
            event.setEventType("USER_VERIFIED");
        }

        log.info("Received user verified event for user: {}", event.getUserId());

        Map<String, Object> params = new HashMap<>();
        params.put("username", event.getUsername());

        SendNotificationRequest request = SendNotificationRequest.builder()
                .userId(event.getUserId())
                .templateCode("user_verified")
                .parameters(params)
                .build();

        notificationService.sendNotification(request);
    }

    // Wallet event listeners

    @KafkaListener(topics = "wallet-events", groupId = "notification-service")
    public void consumeWalletEvents(String message) {
        try {
            // Determine the event type
            NotificationEvent baseEvent = objectMapper.readValue(message, NotificationEvent.class);

            if (baseEvent == null || baseEvent.getEventType() == null) {
                log.warn("Unknown wallet event type: null");
                return;
            }

            if ("WALLET_TRANSACTION".equals(baseEvent.getEventType())) {
                handleWalletTransactionEvent(message);
            } else {
                log.warn("Unknown wallet event type: {}", baseEvent.getEventType());
            }
        } catch (Exception e) {
            log.error("Error processing wallet event", e);
        }
    }

    private void handleWalletTransactionEvent(String message) throws Exception {
        WalletTransactionEvent event = objectMapper.readValue(message, WalletTransactionEvent.class);

        if (event == null || event.getUserId() == null) {
            log.warn("Invalid wallet transaction event: {}", message);
            return;
        }

        // Initialize event type if needed
        if (event.getEventType() == null) {
            event.setEventType("WALLET_TRANSACTION");
        }

        if (event.getTransactionType() == null) {
            log.warn("Wallet transaction event missing transaction type: {}", message);
            return;
        }

        log.info("Received wallet transaction event for user: {}, type: {}",
                event.getUserId(), event.getTransactionType());

        String templateCode;
        switch (event.getTransactionType()) {
            case "DEPOSIT" -> templateCode = "wallet_deposit";
            case "WITHDRAWAL" -> templateCode = "wallet_withdrawal";
            case "TRANSFER" -> templateCode = "wallet_transfer";
            default -> {
                log.warn("Unknown transaction type: {}", event.getTransactionType());
                return;
            }
        }

        Map<String, Object> params = new HashMap<>();
        params.put("amount", event.getAmount());
        params.put("currency", event.getCurrency());
        params.put("newBalance", event.getNewBalance());

        if (event.getCounterpartyName() != null) {
            params.put("counterpartyName", event.getCounterpartyName());
        }

        SendNotificationRequest request = SendNotificationRequest.builder()
                .userId(event.getUserId())
                .templateCode(templateCode)
                .parameters(params)
                .referenceId(event.getTransactionId() != null ? event.getTransactionId().toString() : null)
                .build();

        notificationService.sendNotification(request);
    }

    // Payment request event listeners

    @KafkaListener(topics = "payment-request-events", groupId = "notification-service")
    public void consumePaymentRequestEvents(String message) {
        try {
            // Determine the event type
            NotificationEvent baseEvent = objectMapper.readValue(message, NotificationEvent.class);

            if (baseEvent == null || baseEvent.getEventType() == null) {
                log.warn("Unknown payment request event type: null");
                return;
            }

            if ("PAYMENT_REQUEST".equals(baseEvent.getEventType())) {
                handlePaymentRequestEvent(message);
            } else {
                log.warn("Unknown payment request event type: {}", baseEvent.getEventType());
            }
        } catch (Exception e) {
            log.error("Error processing payment request event", e);
        }
    }

    private void handlePaymentRequestEvent(String message) throws Exception {
        PaymentRequestEvent event = objectMapper.readValue(message, PaymentRequestEvent.class);

        if (event == null || event.getUserId() == null) {
            log.warn("Invalid payment request event: {}", message);
            return;
        }

        // Initialize event type if needed
        if (event.getEventType() == null) {
            event.setEventType("PAYMENT_REQUEST");
        }

        if (event.getStatus() == null) {
            log.warn("Payment request event missing status: {}", message);
            return;
        }

        log.info("Received payment request event for user: {}, status: {}",
                event.getUserId(), event.getStatus());

        String templateCode;
        switch (event.getStatus()) {
            case "CREATED" -> templateCode = "payment_request_created";
            case "APPROVED" -> templateCode = "payment_request_approved";
            case "REJECTED" -> templateCode = "payment_request_rejected";
            case "CANCELED" -> templateCode = "payment_request_canceled";
            case "EXPIRED" -> templateCode = "payment_request_expired";
            default -> {
                log.warn("Unknown payment request status: {}", event.getStatus());
                return;
            }
        }

        Map<String, Object> params = new HashMap<>();
        params.put("amount", event.getAmount());
        params.put("currency", event.getCurrency());

        if (event.getRequestorName() != null) {
            params.put("requestorName", event.getRequestorName());
        }

        if (event.getRecipientName() != null) {
            params.put("recipientName", event.getRecipientName());
        }

        SendNotificationRequest request = SendNotificationRequest.builder()
                .userId(event.getUserId())
                .templateCode(templateCode)
                .parameters(params)
                .referenceId(event.getRequestId() != null ? event.getRequestId().toString() : null)
                .build();

        notificationService.sendNotification(request);
    }

    // Scheduled payment event listeners

    @KafkaListener(topics = "scheduled-payment-events", groupId = "notification-service")
    public void consumeScheduledPaymentEvents(String message) {
        try {
            // Determine the event type
            NotificationEvent baseEvent = objectMapper.readValue(message, NotificationEvent.class);

            if (baseEvent == null || baseEvent.getEventType() == null) {
                log.warn("Unknown scheduled payment event type: null");
                return;
            }

            if ("SCHEDULED_PAYMENT".equals(baseEvent.getEventType())) {
                handleScheduledPaymentEvent(message);
            } else {
                log.warn("Unknown scheduled payment event type: {}", baseEvent.getEventType());
            }
        } catch (Exception e) {
            log.error("Error processing scheduled payment event", e);
        }
    }

    private void handleScheduledPaymentEvent(String message) throws Exception {
        ScheduledPaymentEvent event = objectMapper.readValue(message, ScheduledPaymentEvent.class);

        if (event == null || event.getUserId() == null) {
            log.warn("Invalid scheduled payment event: {}", message);
            return;
        }

        // Initialize event type if needed
        if (event.getEventType() == null) {
            event.setEventType("SCHEDULED_PAYMENT");
        }

        if (event.getStatus() == null) {
            log.warn("Scheduled payment event missing status: {}", message);
            return;
        }

        log.info("Received scheduled payment event for user: {}, status: {}",
                event.getUserId(), event.getStatus());

        String templateCode;
        switch (event.getStatus()) {
            case "CREATED" -> templateCode = "scheduled_payment_created";
            case "EXECUTED" -> templateCode = "scheduled_payment_executed";
            case "FAILED" -> templateCode = "scheduled_payment_failed";
            case "COMPLETED" -> templateCode = "scheduled_payment_completed";
            case "CANCELED" -> templateCode = "scheduled_payment_canceled";
            default -> {
                log.warn("Unknown scheduled payment status: {}", event.getStatus());
                return;
            }
        }

        Map<String, Object> params = new HashMap<>();
        params.put("amount", event.getAmount());
        params.put("currency", event.getCurrency());

        if (event.getExecutionDate() != null) {
            params.put("executionDate", event.getExecutionDate());
        }

        if (event.getSenderName() != null) {
            params.put("senderName", event.getSenderName());
        }

        if (event.getRecipientName() != null) {
            params.put("recipientName", event.getRecipientName());
        }

        SendNotificationRequest request = SendNotificationRequest.builder()
                .userId(event.getUserId())
                .templateCode(templateCode)
                .parameters(params)
                .referenceId(event.getPaymentId() != null ? event.getPaymentId().toString() : null)
                .build();

        notificationService.sendNotification(request);
    }

    // Split payment event listeners

    @KafkaListener(topics = "split-payment-events", groupId = "notification-service")
    public void consumeSplitPaymentEvents(String message) {
        try {
            // Determine the event type
            NotificationEvent baseEvent = objectMapper.readValue(message, NotificationEvent.class);

            if (baseEvent == null || baseEvent.getEventType() == null) {
                log.warn("Unknown split payment event type: null");
                return;
            }

            if ("SPLIT_PAYMENT".equals(baseEvent.getEventType())) {
                handleSplitPaymentEvent(message);
            } else {
                log.warn("Unknown split payment event type: {}", baseEvent.getEventType());
            }
        } catch (Exception e) {
            log.error("Error processing split payment event", e);
        }
    }

    private void handleSplitPaymentEvent(String message) throws Exception {
        SplitPaymentEvent event = objectMapper.readValue(message, SplitPaymentEvent.class);

        if (event == null || event.getUserId() == null) {
            log.warn("Invalid split payment event: {}", message);
            return;
        }

        // Initialize event type if needed
        if (event.getEventType() == null) {
            event.setEventType("SPLIT_PAYMENT");
        }

        if (event.getStatus() == null) {
            log.warn("Split payment event missing status: {}", message);
            return;
        }

        log.info("Received split payment event for user: {}, status: {}",
                event.getUserId(), event.getStatus());

        String templateCode;
        switch (event.getStatus()) {
            case "CREATED" -> templateCode = "split_payment_created";
            case "PARTICIPANT_ADDED" -> templateCode = "split_payment_participant_added";
            case "PARTICIPANT_PAID" -> templateCode = "split_payment_participant_paid";
            case "COMPLETED" -> templateCode = "split_payment_completed";
            case "CANCELED" -> templateCode = "split_payment_canceled";
            default -> {
                log.warn("Unknown split payment status: {}", event.getStatus());
                return;
            }
        }

        Map<String, Object> params = new HashMap<>();
        params.put("title", event.getTitle());
        params.put("totalAmount", event.getTotalAmount());
        params.put("currency", event.getCurrency());

        if (event.getUserAmount() != null) {
            params.put("userAmount", event.getUserAmount());
        }

        if (event.getOrganizerName() != null) {
            params.put("organizerName", event.getOrganizerName());
        }

        if (event.getParticipantName() != null) {
            params.put("participantName", event.getParticipantName());
        }

        SendNotificationRequest request = SendNotificationRequest.builder()
                .userId(event.getUserId())
                .templateCode(templateCode)
                .parameters(params)
                .referenceId(event.getPaymentId() != null ? event.getPaymentId().toString() : null)
                .build();

        notificationService.sendNotification(request);
    }

    // Security event listeners

    @KafkaListener(topics = "security-events", groupId = "notification-service")
    public void consumeSecurityEvents(String message) {
        try {
            // Determine the event type
            NotificationEvent baseEvent = objectMapper.readValue(message, NotificationEvent.class);

            if (baseEvent == null || baseEvent.getEventType() == null) {
                log.warn("Unknown security event type: null");
                return;
            }

            if ("SECURITY".equals(baseEvent.getEventType())) {
                handleSecurityEvent(message);
            } else {
                log.warn("Unknown security event type: {}", baseEvent.getEventType());
            }
        } catch (Exception e) {
            log.error("Error processing security event", e);
        }
    }

    private void handleSecurityEvent(String message) throws Exception {
        SecurityEvent event = objectMapper.readValue(message, SecurityEvent.class);

        if (event == null || event.getUserId() == null) {
            log.warn("Invalid security event: {}", message);
            return;
        }

        // Initialize event type if needed
        if (event.getEventType() == null) {
            event.setEventType("SECURITY");
        }

        if (event.getSecurityEventType() == null) {
            log.warn("Security event missing security event type: {}", message);
            return;
        }

        log.info("Received security event for user: {}, type: {}",
                event.getUserId(), event.getSecurityEventType());

        String templateCode;
        switch (event.getSecurityEventType()) {
            case "LOGIN" -> templateCode = "security_login";
            case "PASSWORD_CHANGED" -> templateCode = "security_password_changed";
            case "DEVICE_ADDED" -> templateCode = "security_device_added";
            case "SUSPICIOUS_ACTIVITY" -> templateCode = "security_suspicious_activity";
            default -> {
                log.warn("Unknown security event type: {}", event.getSecurityEventType());
                return;
            }
        }

        Map<String, Object> params = new HashMap<>();
        if (event.getEventTime() != null) {
            params.put("eventTime", event.getEventTime());
        }

        if (event.getIpAddress() != null) {
            params.put("ipAddress", event.getIpAddress());
        }

        if (event.getDeviceInfo() != null) {
            params.put("deviceInfo", event.getDeviceInfo());
        }

        if (event.getLocation() != null) {
            params.put("location", event.getLocation());
        }

        // For suspicious activities, always send via email too
        String[] types = event.isSuspicious() ? new String[] { "APP", "EMAIL" } : null;

        SendNotificationRequest request = SendNotificationRequest.builder()
                .userId(event.getUserId())
                .templateCode(templateCode)
                .parameters(params)
                .types(types)
                .build();

        notificationService.sendNotification(request);
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/event/NotificationEvent.java

**Dependencies:**
- External: `java.time.LocalDateTime`, `java.util.UUID`, `lombok.Data`

```java
package com.waqiti.notification.event;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.UUID; /**
 * Base class for all notification events
 */
@Data
public abstract class NotificationEvent {
    private String eventId;
    private String eventType;
    private LocalDateTime timestamp;
    private UUID userId;

    public NotificationEvent() {
        this.eventId = UUID.randomUUID().toString();
        this.timestamp = LocalDateTime.now();
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/event/SplitPaymentEvent.java

**Dependencies:**
- External: `java.math.BigDecimal`, `java.util.UUID`, `lombok.AllArgsConstructor` and 4 more

```java
/**
 * File: src/main/java/com/waqiti/notification/event/SplitPaymentEvent.java
 */
package com.waqiti.notification.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.EqualsAndHashCode;

import java.math.BigDecimal;
import java.util.UUID;

/**
 * Event for split payments
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class SplitPaymentEvent extends NotificationEvent {
    private UUID userId;
    private UUID paymentId;
    private String status; // CREATED, PARTICIPANT_ADDED, PARTICIPANT_PAID, COMPLETED, CANCELED
    private UUID organizerId;
    private String organizerName;
    private String title;
    private BigDecimal totalAmount;
    private BigDecimal userAmount;
    private String currency;
    private UUID participantId;
    private String participantName;

    // Use setter method instead of direct field access
    public void initializeEventType() {
        this.setEventType("SPLIT_PAYMENT");
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/event/UserRegisteredEvent.java

**Dependencies:**
- External: `java.util.UUID`, `javax.annotation.PostConstruct`, `lombok.AllArgsConstructor` and 4 more

```java
/**
 * File: src/main/java/com/waqiti/notification/event/UserRegisteredEvent.java
 */
package com.waqiti.notification.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.EqualsAndHashCode;

import javax.annotation.PostConstruct;
import java.util.UUID;

/**
 * Event for user registration
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class UserRegisteredEvent extends NotificationEvent {
    private UUID userId;
    private String username;
    private String email;

    // You can add a method to set the event type after construction
    @PostConstruct
    private void init() {
        this.setEventType("USER_REGISTERED");
    }

    // For manually setting the event type when not using Spring
    public void initializeEventType() {
        this.setEventType("USER_REGISTERED");
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/event/SecurityEvent.java

**Dependencies:**
- External: `java.time.LocalDateTime`, `java.util.UUID`, `lombok.AllArgsConstructor` and 4 more

```java
/**
 * File: src/main/java/com/waqiti/notification/event/SecurityEvent.java
 */
package com.waqiti.notification.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.EqualsAndHashCode;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Event for security related notifications
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class SecurityEvent extends NotificationEvent {
    private UUID userId;
    private String securityEventType; // LOGIN, PASSWORD_CHANGED, DEVICE_ADDED, etc.
    private String ipAddress;
    private String deviceInfo;
    private String location;
    private LocalDateTime eventTime;
    private boolean suspicious;

    // Use setter method instead of direct field access
    public void initializeEventType() {
        this.setEventType("SECURITY");
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/event/UserVerifiedEvent.java

**Dependencies:**
- External: `java.util.UUID`, `javax.annotation.PostConstruct`, `lombok.AllArgsConstructor` and 4 more

```java
/**
 * File: src/main/java/com/waqiti/notification/event/UserVerifiedEvent.java
 */
package com.waqiti.notification.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.EqualsAndHashCode;

import javax.annotation.PostConstruct;
import java.util.UUID;

/**
 * Event for user verification
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class UserVerifiedEvent extends NotificationEvent {
    private UUID userId;
    private String username;

    // You can add a method to set the event type after construction
    @PostConstruct
    private void init() {
        this.setEventType("USER_VERIFIED");
    }

    // For manually setting the event type when not using Spring
    public void initializeEventType() {
        this.setEventType("USER_VERIFIED");
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/event/PaymentRequestEvent.java

**Dependencies:**
- External: `java.math.BigDecimal`, `java.util.UUID`, `lombok.AllArgsConstructor` and 4 more

```java
/**
 * File: src/main/java/com/waqiti/notification/event/PaymentRequestEvent.java
 */
package com.waqiti.notification.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.EqualsAndHashCode;

import java.math.BigDecimal;
import java.util.UUID;

/**
 * Event for payment requests
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class PaymentRequestEvent extends NotificationEvent {
    private UUID userId;
    private UUID requestId;
    private String status; // CREATED, APPROVED, REJECTED, CANCELED, EXPIRED
    private UUID requestorId;
    private String requestorName;
    private UUID recipientId;
    private String recipientName;
    private BigDecimal amount;
    private String currency;

    // Use setter method instead of direct field access
    public void initializeEventType() {
        this.setEventType("PAYMENT_REQUEST");
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/event/WalletTransactionEvent.java

**Dependencies:**
- External: `java.math.BigDecimal`, `java.util.UUID`, `lombok.AllArgsConstructor` and 4 more

```java
/**
 * File: src/main/java/com/waqiti/notification/event/WalletTransactionEvent.java
 */
package com.waqiti.notification.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.EqualsAndHashCode;

import java.math.BigDecimal;
import java.util.UUID;

/**
 * Event for wallet transactions
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class WalletTransactionEvent extends NotificationEvent {
    private UUID userId;
    private UUID walletId;
    private String transactionType; // DEPOSIT, WITHDRAWAL, TRANSFER
    private BigDecimal amount;
    private String currency;
    private UUID sourceWalletId;
    private UUID targetWalletId;
    private UUID counterpartyUserId;
    private String counterpartyName;
    private BigDecimal newBalance;
    private UUID transactionId;

    // Use setter method instead of direct field access
    public void initializeEventType() {
        this.setEventType("WALLET_TRANSACTION");
    }
}
```

### notification-service/src/main/java/com/waqiti/notification/event/ScheduledPaymentEvent.java

**Dependencies:**
- External: `java.math.BigDecimal`, `java.time.LocalDateTime`, `java.util.UUID` and 5 more

```java
/**
 * File: src/main/java/com/waqiti/notification/event/ScheduledPaymentEvent.java
 */
package com.waqiti.notification.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.EqualsAndHashCode;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Event for scheduled payments
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class ScheduledPaymentEvent extends NotificationEvent {
    private UUID userId;
    private UUID paymentId;
    private String status; // CREATED, EXECUTED, FAILED, COMPLETED, CANCELED
    private UUID senderId;
    private String senderName;
    private UUID recipientId;
    private String recipientName;
    private BigDecimal amount;
    private String currency;
    private LocalDateTime executionDate;

    // Use setter method instead of direct field access
    public void initializeEventType() {
        this.setEventType("SCHEDULED_PAYMENT");
    }
}
```

